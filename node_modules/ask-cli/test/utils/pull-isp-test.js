'use strict';

const expect = require('chai').expect;
const sinon = require('sinon');
const fs = require('fs');
const jsonfile = require('jsonfile');
const ispUtil = require('../../lib/utils/isp-utils/isp-utility');
const cloneISPUtil = require('../../lib/clone/clone-isp');
const ispConstant = require('../../lib/utils/isp-utils/isp-constants');
const pullISPUtil = require('../../lib/utils/isp-utils/pull-isp');

describe('Pull ISP testing', () => {
    const compareIspConfig = (a, b) => {
        return (a.productId < b.productId ? -1 : (a.productId > b.productId ? 1 : 0));
    };
    describe('# test pullISP', () => {
        let sandbox;
        beforeEach(() => {
            sandbox = sinon.sandbox.create();
            sandbox.stub(ispUtil, 'getISPConfigs');
            sandbox.stub(ispUtil, 'replaceISPConfigs');
            sandbox.stub(fs, 'existsSync');
            sandbox.stub(cloneISPUtil, 'getISPs');
            sandbox.stub(jsonfile, 'writeFile');
        });

        afterEach(() => {
            sandbox.restore();
        });
        const ispToUpdateConfig_1 = {
            productId: 'isp_id_1',
            filePath: 'isp_file_1',
            deploy_status: ispConstant.DEPLOY_STATUS.UPDATE,
            eTag: 'etag_1'
        };
        const ispToUpdateConfig_2 = {
            productId: 'isp_id_2',
            filePath: 'isp_file_2',
            deploy_status: ispConstant.DEPLOY_STATUS.UPDATE,
            eTag: 'etag_2'
        };

        it('| Succeed to pull ISPs', () => {
            fs.existsSync.returns(true);
            ispUtil.getISPConfigs.returns([ispToUpdateConfig_1, ispToUpdateConfig_2]);
            ispUtil.replaceISPConfigs.returns(null);
            const ispInfoMap = new Map();
            const ispInfo = {
                productId: 'isp_id_1',
                definition: {},
                eTag: 'etag_1_1'
            };
            ispInfoMap.set(ispToUpdateConfig_1.productId, ispInfo);
            cloneISPUtil.getISPs.yields(null, ispInfoMap);
            jsonfile.writeFile.yields(null);

            const ispToPull = new Set();
            ispToPull.add(ispToUpdateConfig_1.productId);

            pullISPUtil.pullISP(ispToPull, 'foo', 'foo', null, (error, ispConfigList) => {
                ispToUpdateConfig_1.eTag = 'etag_1_1';
                expect(ispConfigList.sort(compareIspConfig)).to.eql([ispToUpdateConfig_1, ispToUpdateConfig_2].sort(compareIspConfig));
            });
        });

        it('Failed to pull ISP when ispToPull is invalid', () => {
            pullISPUtil.pullISP(null, 'foo', 'foo', null, (error) => {
                expect(error).to.equal('A set of in-skill product(s) to pull need to be provided.');
            });
            pullISPUtil.pullISP(['id_1', 'id_2'], 'foo', 'foo', null, (error) => {
                expect(error).to.equal('A set of in-skill product(s) to pull need to be provided.');
            });
        });

        it('Failed to pull ISP when skillProjectPath is invalid', () => {
            const skillProjectPath = 'foo';
            fs.existsSync.withArgs(skillProjectPath).returns(false);
            const ispToPull = new Set();
            ispToPull.add('isp_id_1');
            pullISPUtil.pullISP(ispToPull, skillProjectPath, 'foo', null, (error) => {
                expect(error).to.equal('Invalid path of the skill project.');
            });
        });
        it('Failed to pull ISP when it failed to get in-skill product information from remote', () => {
            fs.existsSync.returns(true);
            ispUtil.getISPConfigs.returns([ispToUpdateConfig_1, ispToUpdateConfig_2]);
            ispUtil.replaceISPConfigs.returns(null);
            cloneISPUtil.getISPs.yields('getISPError');
            jsonfile.writeFile.yields(null);

            const ispToPull = new Set();
            ispToPull.add(ispToUpdateConfig_1.productId);

            pullISPUtil.pullISP(ispToPull, 'foo', 'foo', null, (error) => {
                expect(error).to.equal('getISPError');
            });
        });
    });
});
