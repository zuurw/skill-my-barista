'use strict';

const expect = require('chai').expect;
const sinon = require('sinon');
const crypto = require('crypto');
const fs = require('fs');
const jsonUtility = require('../../lib/utils/json-utility');
const path = require('path');

const tools = require('../../lib/utils/tools');

describe('utils tools testing', () => {
    describe('# convert data to json object', () => {
        beforeEach(() => {
            sinon.stub(console, 'error');
        });

        afterEach(() => {
            console.error.restore();
        });

        it('| display error message when data can not be parsed', () => {
            tools.convertDataToJsonObject('invalid data');
            expect(console.error.getCall(0).args[0]).equal('Failed to parse the response from Alexa Skill Management API Service.');
        });

        it('| should separately escape from skill definition', () => {
            sinon.stub(JSON, 'parse');
            JSON.parse.returns({manifest: 'skill'});
            tools.convertDataToJsonObject('data');
            expect(JSON.parse.callCount).equal(1);
            JSON.parse.restore();
        });

        it('| should separately escape from model definition', () => {
            sinon.stub(JSON, 'parse');
            JSON.parse.returns({modelDefinition: 'model'});
            tools.convertDataToJsonObject('data');
            expect(JSON.parse.callCount).equal(1);
            JSON.parse.restore();
        });

        it('| should separately escape from account linking information', () => {
            sinon.stub(JSON, 'parse');
            JSON.parse.returns({accountLinkingInfo: 'account linking'});
            tools.convertDataToJsonObject('data');
            expect(JSON.parse.callCount).equal(1);
            JSON.parse.restore();
        });
    });

    describe('# remove directory', () => {
        let sandbox;

        beforeEach(() => {
            sandbox = sinon.sandbox.create();

            sandbox.stub(fs, 'existsSync');
            sandbox.stub(fs, 'readdirSync');
            sandbox.stub(fs, 'rmdirSync');
            sandbox.stub(fs, 'unlinkSync');
        });

        afterEach(() => {
            sandbox.restore();
        });

        it('| no remove call if directory does not exist', () => {
            tools.removeDirectory('path');
            fs.existsSync.returns(false);
            expect(fs.rmdirSync.callCount).equal(0);
        });
    });

    describe('# generate SID', () => {
        beforeEach(() => {
            sinon.stub(crypto, 'randomBytes');
        });

        afterEach(() => {
            crypto.randomBytes.restore();
        });

        it('| call 5 times of crypto in total', () => {
            crypto.randomBytes.returns('256');
            tools.generateSID();
            expect(crypto.randomBytes.callCount).equal(5);
        });
    });

    describe('# v1ManifestTransformer', () => {
        let sandbox;

        beforeEach(() => {
            sandbox = sinon.sandbox.create();

            sandbox.stub(jsonUtility, 'read');
            sandbox.stub(jsonUtility, 'write');
            sandbox.stub(console, 'warn');
            sandbox.stub(fs, 'existsSync');
            sandbox.stub(process, 'cwd');

        });

        afterEach(() => {
            sandbox.restore();
        });

        it('| v1 version of skill.json on low level command', () => {
            let skillJSONContent = {
                'manifest': 'test'
            };

            jsonUtility.read.withArgs('TEST').returns(skillJSONContent);
            tools.v1ManifestTransformer('TEST', true);
            expect(jsonUtility.write.called).equal(false);
            expect(console.warn.called).equal(false);
        });

        it('| v1 version for skill.json and config on high level command', () => {
            let skillJSONContent = {
                'manifest': 'skill_test'
            };

            let configContent = {
                "deploy_settings": {
                    "default": {
                        "merge": {
                            "manifest": 'config_test'
                        }
                    }
                }
            };

            jsonUtility.read.withArgs('TEST').returns(skillJSONContent);
            fs.existsSync.returns(true);
            process.cwd.returns('CWD');
            jsonUtility.read.withArgs(path.join('CWD', '.ask', 'config')).returns(configContent);
            tools.v1ManifestTransformer('TEST', false, 'Profile');
            expect(jsonUtility.write.called).equal(false);
            expect(console.warn.called).equal(false);
        });

        it('| v0 version of skill.json with skillManifest to manifest change for low level command', () => {
            let skillJSONContent = {
                'skillManifest': 'test'
            };
            jsonUtility.read.withArgs('TEST').returns(skillJSONContent);
            tools.v1ManifestTransformer('TEST', true);

            expect(jsonUtility.write.getCall(0).args[0]).equal('TEST');
            expect(jsonUtility.write.getCall(0).args[1].hasOwnProperty('manifest')).equal(true);
            expect(jsonUtility.write.getCall(0).args[1].hasOwnProperty('skillManifest')).equal(false);

            expect(console.warn.calledOnce).equal(true);
        });

        it ('| v0 version for both skill.json and config on high level command', () => {
            const profile = 'default';
            let skillJSONContent = {
                'skillManifest': 'skill_test'
            };

            let configContent = {
                "deploy_settings": {
                    [profile] : {
                        "merge": {
                            "skillManifest": 'config_test'
                        }
                    }
                }
            };

            jsonUtility.read.withArgs('TEST').returns(skillJSONContent);
            fs.existsSync.returns(true);
            process.cwd.returns('CWD');
            jsonUtility.read.withArgs(path.join('CWD', '.ask', 'config')).returns(configContent);
            tools.v1ManifestTransformer('TEST', false, profile);

            expect(jsonUtility.write.calledTwice).equal(true);
            expect(jsonUtility.write.getCall(0).args[0]).equal('TEST');
            expect(jsonUtility.write.getCall(0).args[1].hasOwnProperty('manifest')).equal(true);
            expect(jsonUtility.write.getCall(0).args[1].hasOwnProperty('skillManifest')).equal(false);

            expect(jsonUtility.write.getCall(1).args[1]
                .deploy_settings.default.merge.hasOwnProperty('manifest')).equal(true);
            expect(jsonUtility.write.getCall(1).args[1]
                .deploy_settings.default.merge.hasOwnProperty('skillManifest')).equal(false);

            expect(console.warn.called).equal(true);

        });
    })
});
