'use strict';

const expect = require('chai').expect;
const sinon = require('sinon');
const ifMatchUtil = require('../../lib/utils/if-match-utility');
const jsonUtility = require('../../lib/utils/json-utility');
const path = require('path');

describe('utils if-match-utility testing', () => {
    const profile = 'TEST_PROFILE';

    describe('# recordModelEtag', () => {
        let sandbox;
        let config;
        let eTagList;
        let configPath;

        beforeEach(() => {
            sandbox = sinon.sandbox.create();
            sandbox.stub(jsonUtility, 'read');
            sandbox.stub(jsonUtility, 'write');
            sandbox.stub(jsonUtility, 'insertObjectToObject');

            eTagList = [
                {
                    eTag: 'eTag_en_US',
                    locale: 'en_US'
                },
                {
                    eTag: 'eTag_en_GB',
                    locale: 'en_GB'
                }
            ];

            config = {
                'deploy_settings': {}
            };

            config.deploy_settings[profile] = {
                'resources': {}
            };

        });
        afterEach(() => {
            sandbox.restore();
        });


        it('| should insert model eTag to config which config path is default to workspace/.ask/config', () => {
            configPath = path.join(process.cwd(), '.ask', 'config');
            jsonUtility.read.withArgs(configPath).returns(config);

            ifMatchUtil.recordModelEtag(eTagList, profile, configPath);

            let firstCall = jsonUtility.insertObjectToObject.getCalls()[0].args;
            console.log(firstCall);
            expect(firstCall[0]).deep.equal(config);
            expect(firstCall[1].slice(-1)[0]).equal(eTagList[0].locale);
            expect(JSON.stringify(firstCall[2]))
                .equal(JSON.stringify({eTag: eTagList[0].eTag}));

            let secondCall = jsonUtility.insertObjectToObject.getCalls()[1].args;
            expect(secondCall[1].slice(-1)[0]).equal(eTagList[1].locale);
            expect(JSON.stringify(secondCall[2]))
                .equal(JSON.stringify({eTag: eTagList[1].eTag}));

            expect(jsonUtility.write.getCall(0).args[0]).equal(configPath);
        });

        it('| should insert model eTag to config with custom config path', () => {
            configPath = 'CONFIG_PATH';
            jsonUtility.read.withArgs(configPath).returns(config);

            ifMatchUtil.recordModelEtag(eTagList, profile, configPath);

            let firstCall = jsonUtility.insertObjectToObject.getCalls()[0].args;
            expect(JSON.stringify(firstCall[0])).equal(JSON.stringify(config));
            expect(firstCall[1].slice(-1)[0]).equal(eTagList[0].locale);
            expect(JSON.stringify(firstCall[2]))
                .equal(JSON.stringify({eTag: eTagList[0].eTag}));

            let secondCall = jsonUtility.insertObjectToObject.getCalls()[1].args;
            expect(secondCall[1].slice(-1)[0]).equal(eTagList[1].locale);
            expect(JSON.stringify(secondCall[2]))
                .equal(JSON.stringify({eTag: eTagList[1].eTag}));

            expect(jsonUtility.write.getCall(0).args[0]).equal(configPath);
        });

        it('| should not call jsonUtil if eTaglist is null', () => {
            ifMatchUtil.recordModelEtag(null, profile);
            expect(jsonUtility.read.called).equal(false);
            expect(jsonUtility.write.called).equal(false);
            expect(jsonUtility.insertObjectToObject.called).equal(false);
        });

        it('| should not call jsonUtil if eTaglist is empty array', () => {
            ifMatchUtil.recordModelEtag([], profile);
            expect(jsonUtility.read.called).equal(false);
            expect(jsonUtility.write.called).equal(false);
            expect(jsonUtility.insertObjectToObject.called).equal(false);
        });
    });

    describe('# recordSkillEtag', () => {
        let sandbox;
        let config;
        let eTag;
        let configPath;

        beforeEach(() => {
            sandbox = sinon.sandbox.create();
            sandbox.stub(jsonUtility, 'writeToProperty');
            eTag = 'TEST_ETAG';
        });
        afterEach(() => {
            sandbox.restore();
        });



        it('| should insert skill eTag to config which config path is default to workspace/.ask/config', () => {
            configPath = path.join(process.cwd(), '.ask', 'config');

            ifMatchUtil.recordSkillEtag(eTag, profile, configPath);

            let call = jsonUtility.writeToProperty.getCalls()[0].args;
            expect(JSON.stringify(call[0])).equal(JSON.stringify(configPath));
            expect(call[1].slice(-1)[0]).equal('manifest');
            expect(JSON.stringify(call[2]))
                .equal(JSON.stringify({eTag: eTag}));

        });

        it('| should insert skill eTag to config with custom config path', () => {
            configPath = 'CONFIG_PATH';

            ifMatchUtil.recordSkillEtag(eTag, profile, configPath);

            let call = jsonUtility.writeToProperty.getCalls()[0].args;
            expect(JSON.stringify(call[0])).equal(JSON.stringify(configPath));
            expect(call[1].slice(-1)[0]).equal('manifest');
            expect(JSON.stringify(call[2]))
                .equal(JSON.stringify({eTag: eTag}));
        });

        it('| should not call jsonUtil if eTag is null', () => {
            ifMatchUtil.recordSkillEtag(null, profile);
            expect(jsonUtility.writeToProperty.called).equal(false);
        });
    });

    describe('# recordLambdaRevisionId', () => {
        let sandbox;
        let config;
        let lambdaMetaDataObjectList;
        let configPath;

        beforeEach(() => {
            sandbox = sinon.sandbox.create();
            sandbox.stub(jsonUtility, 'read');
            sandbox.stub(jsonUtility, 'write');
            sandbox.stub(jsonUtility, 'insertObjectToObject');
            sandbox.stub(jsonUtility, 'getPropertyValueFromObject');

            lambdaMetaDataObjectList = [
                {
                    domain: 'custom',
                    uri: 'NA_URI',
                    revisionId: 'NA_R_I'
                },{
                    domain: 'custom',
                    uri: 'EU_URI',
                    revisionId: 'EU_R_I'
                },
                {
                    domain: 'music',
                    uri: 'FE_URI',
                    revisionId: 'FE_R_I'
                }
            ];

            config = {
                'deploy_settings': {}
            };

            config.deploy_settings[profile] = {
                'resources': {}
            }

        });
        afterEach(() => {
            sandbox.restore();
        });



        it('| should insert lambda revision id to config which config path is default to workspace/.ask/config', () => {
            configPath = path.join(process.cwd(), '.ask', 'config');
            let musicPath = ['deploy_settings', profile, 'resources', 'lambda', 'music'];
            let musicArray = [];
            let customPath = ['deploy_settings', profile, 'resources', 'lambda', 'custom'];
            let customArray = [];

            jsonUtility.read.withArgs(configPath).returns(config);
            jsonUtility.getPropertyValueFromObject.withArgs(config, musicPath).returns(musicArray);

            jsonUtility.getPropertyValueFromObject.onCall(0).returns(null);
            jsonUtility.getPropertyValueFromObject.returns(customArray);


            ifMatchUtil.recordLambdaRevisionId(lambdaMetaDataObjectList, profile);

            let firstCall = jsonUtility.insertObjectToObject.getCalls()[0].args;
            expect(JSON.stringify(firstCall[0])).equal(JSON.stringify(config));
            //lambda path, check the 2nd item
            expect(firstCall[1][1]).equal(profile);
            expect(JSON.stringify(firstCall[2])).equal(JSON.stringify({custom: []}));

            expect(musicArray[0].uri).equal(lambdaMetaDataObjectList[2].uri);
            expect(musicArray[0].RevisionId).equal(lambdaMetaDataObjectList[2].revisionId);


            //
            // let secondCall = jsonUtility.insertObjectToObject.getCalls()[1].args;
            // expect(secondCall[1].slice(-1)[0]).equal(eTagList[1].locale);
            // expect(JSON.stringify(secondCall[2]))
            //     .equal(JSON.stringify({eTag: eTagList[1].eTag}));
            //
            expect(jsonUtility.write.getCall(0).args[0]).equal(configPath);
        });

        // it('| should insert model eTag to config with custom config path', () => {
        //     configPath = 'CONFIG_PATH';
        //     jsonUtility.read.withArgs(configPath).returns(config);

        //     ifMatchUtil.recordModelEtag(eTagList, profile, configPath);

        //     let firstCall = jsonUtility.insertObjectToObject.getCalls()[0].args;
        //     expect(JSON.stringify(firstCall[0])).equal(JSON.stringify(config));
        //     expect(firstCall[1].slice(-1)[0]).equal(eTagList[0].locale);
        //     expect(JSON.stringify(firstCall[2]))
        //         .equal(JSON.stringify({eTag: eTagList[0].eTag}));

        //     let secondCall = jsonUtility.insertObjectToObject.getCalls()[1].args;
        //     expect(secondCall[1].slice(-1)[0]).equal(eTagList[1].locale);
        //     expect(JSON.stringify(secondCall[2]))
        //         .equal(JSON.stringify({eTag: eTagList[1].eTag}));

        //     expect(jsonUtility.write.getCall(0).args[0]).equal(configPath);
        // });

        it('| should not call jsonUtil if downloadedLambdaMetaDataObjectList is null', () => {
            ifMatchUtil.recordLambdaRevisionId(null, profile);
            expect(jsonUtility.read.called).equal(false);
            expect(jsonUtility.write.called).equal(false);
            expect(jsonUtility.insertObjectToObject.called).equal(false);
            expect(jsonUtility.getPropertyValueFromObject.called).equal(false);

        });

        it('| should not call jsonUtil if downloadedLambdaMetaDataObjectList is empty array', () => {
            ifMatchUtil.recordLambdaRevisionId([], profile);
            expect(jsonUtility.read.called).equal(false);
            expect(jsonUtility.write.called).equal(false);
            expect(jsonUtility.insertObjectToObject.called).equal(false);
            expect(jsonUtility.getPropertyValueFromObject.called).equal(false);
        });
    });

});
