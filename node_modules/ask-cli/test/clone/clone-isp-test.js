'use strict';

const expect = require('chai').expect;
const sinon = require('sinon');
const fs = require('fs');
const mkdirp = require('mkdirp');
const path = require('path');
const jsonfile = require('jsonfile');
const ispUtil = require('../../lib/utils/isp-utils/isp-utility');
const ispConstant = require('../../lib/utils/isp-utils/isp-constants');
const apiWrapper = require('../../lib/api/api-wrapper');
const cloneISPUtil = require('../../lib/clone/clone-isp');

describe('Clone ISP testing', () => {
    const compareIspInfo = (a, b) => {
        return (a.productId < b.productId ? -1 : (a.productId > b.productId ? 1 : 0));
    };
    const skillProjectPath = 'SkillProject';
    const profile = 'default';
    describe('# test downloadISPFiles', () => {
        let sandbox;
        beforeEach(() => {
            sandbox = sinon.sandbox.create();
            sandbox.stub(fs, 'existsSync');
            sandbox.stub(jsonfile, 'writeFile');
            sandbox.stub(apiWrapper, 'callGetISP');
            sandbox.stub(mkdirp, 'mkdirP');
        });

        afterEach(() => {
            sandbox.restore();
        });

        it('| Succeed to download list of ISPs', () => {
            const clock = sandbox.useFakeTimers();
            const ispIdList = ['isp_id_1', 'isp_id_2', 'isp_id_3'];
            const getISPResponseList = [
                {
                    inSkillProductDefinition: {
                        referenceName: 'isp_name_1',
                        type: ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT
                    }
                },
                {
                    inSkillProductDefinition: {
                        referenceName: 'isp_name_2',
                        type: ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT
                    }
                },
                {
                    inSkillProductDefinition: {
                        referenceName: 'isp_name_3',
                        type: ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT
                    }
                }
            ];
            const eTagList = ['eTag1', 'eTag2', 'eTag3'];
            /**
             * Mocks
             */
            fs.existsSync.returns(false);
            apiWrapper.callGetISP.withArgs(ispIdList[0], ispConstant.ISP_STAGE.DEVELOPMENT, false, profile, null).yields(null, getISPResponseList[0], eTagList[0]);
            apiWrapper.callGetISP.withArgs(ispIdList[1], ispConstant.ISP_STAGE.DEVELOPMENT, false, profile, null).yields(null, getISPResponseList[1], eTagList[1]);
            apiWrapper.callGetISP.withArgs(ispIdList[2], ispConstant.ISP_STAGE.DEVELOPMENT, false, profile, null).yields(null, getISPResponseList[2], eTagList[2]);
            mkdirp.mkdirP.yields(null);
            jsonfile.writeFile.yields(null);

            cloneISPUtil.downloadISPFiles(ispIdList, skillProjectPath, profile, null, (error, ispInfoList) => {
                expect(error).to.equal(null);
                expect(ispInfoList.sort(compareIspInfo)).to.eql([
                    {
                        productId: ispIdList[0],
                        filePath: path.join(ispUtil.getISPRootPath(''), ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT.toLowerCase(), ispUtil.getISPFileName(getISPResponseList[0].inSkillProductDefinition.referenceName, null)),
                        eTag: eTagList[0]
                    },
                    {
                        productId: ispIdList[1],
                        filePath: path.join(ispUtil.getISPRootPath(''), ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT.toLowerCase(), ispUtil.getISPFileName(getISPResponseList[1].inSkillProductDefinition.referenceName, null)),
                        eTag: eTagList[1]
                    },
                    {
                        productId: ispIdList[2],
                        filePath: path.join(ispUtil.getISPRootPath(''), ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT.toLowerCase(), ispUtil.getISPFileName(getISPResponseList[2].inSkillProductDefinition.referenceName, null)),
                        eTag: eTagList[2]
                    }
                ].sort(compareIspInfo));
            });
            clock.tick(6000); //Wait for it
        });
        it('| Succeed to download list of ISPs with duplicated reference names', () => {
            const clock = sandbox.useFakeTimers();
            const ispIdList = ['isp_id_1', 'isp_id_2', 'isp_id_3'];
            const getISPResponseList = [
                {
                    inSkillProductDefinition: {
                        referenceName: 'isp_name',
                        type: ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT
                    }
                },
                {
                    inSkillProductDefinition: {
                        referenceName: 'isp_name',
                        type: ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT
                    }
                },
                {
                    inSkillProductDefinition: {
                        referenceName: 'isp_name',
                        type: ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT
                    }
                }
            ];
            const eTagList = ['eTag1', 'eTag2', 'eTag3'];
            /**
             * Mocks
             */
            fs.existsSync.returns(false);
            apiWrapper.callGetISP.withArgs(ispIdList[0], ispConstant.ISP_STAGE.DEVELOPMENT, false, profile, null).yields(null, getISPResponseList[0], eTagList[0]);
            apiWrapper.callGetISP.withArgs(ispIdList[1], ispConstant.ISP_STAGE.DEVELOPMENT, false, profile, null).yields(null, getISPResponseList[1], eTagList[1]);
            apiWrapper.callGetISP.withArgs(ispIdList[2], ispConstant.ISP_STAGE.DEVELOPMENT, false, profile, null).yields(null, getISPResponseList[2], eTagList[2]);
            mkdirp.mkdirP.yields(null);
            jsonfile.writeFile.yields(null);

            cloneISPUtil.downloadISPFiles(ispIdList, skillProjectPath, profile, null, (error, ispInfoList) => {
                expect(error).to.equal(null);
                expect(ispInfoList.sort(compareIspInfo)).to.eql([
                    {
                        productId: ispIdList[0],
                        filePath: path.join(ispUtil.getISPRootPath(''), ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT.toLowerCase(), ispUtil.getISPFileName(getISPResponseList[0].inSkillProductDefinition.referenceName, null)),
                        eTag: eTagList[0]
                    },
                    {
                        productId: ispIdList[1],
                        filePath: path.join(ispUtil.getISPRootPath(''), ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT.toLowerCase(), ispUtil.getISPFileName(getISPResponseList[1].inSkillProductDefinition.referenceName, 2)),
                        eTag: eTagList[1]
                    },
                    {
                        productId: ispIdList[2],
                        filePath: path.join(ispUtil.getISPRootPath(''), ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT.toLowerCase(), ispUtil.getISPFileName(getISPResponseList[2].inSkillProductDefinition.referenceName, 3)),
                        eTag: eTagList[2]
                    }
                ].sort(compareIspInfo));
            });
            clock.tick(6000); //Wait for it
        });
        it('| Fails when mkdirp callback with errors', () => {
            const clock = sandbox.useFakeTimers();
            const ispIdList = ['isp_id_1', 'isp_id_2', 'isp_id_3'];
            const getISPResponseList = [
                {
                    inSkillProductDefinition: {
                        referenceName: 'isp_name_1',
                        type: ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT
                    }
                },
                {
                    inSkillProductDefinition: {
                        referenceName: 'isp_name_2',
                        type: ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT
                    }
                },
                {
                    inSkillProductDefinition: {
                        referenceName: 'isp_name_3',
                        type: ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT
                    }
                }
            ];
            const eTagList = ['eTag1', 'eTag2', 'eTag3'];
            /**
             * Mocks
             */
            fs.existsSync.returns(false);
            apiWrapper.callGetISP.withArgs(ispIdList[0], ispConstant.ISP_STAGE.DEVELOPMENT, false, profile, null).yields(null, getISPResponseList[0], eTagList[0]);
            apiWrapper.callGetISP.withArgs(ispIdList[1], ispConstant.ISP_STAGE.DEVELOPMENT, false, profile, null).yields(null, getISPResponseList[1], eTagList[1]);
            apiWrapper.callGetISP.withArgs(ispIdList[2], ispConstant.ISP_STAGE.DEVELOPMENT, false, profile, null).yields(null, getISPResponseList[2], eTagList[2]);
            const errorMessage = 'Cannot create directory';
            mkdirp.mkdirP.yields(errorMessage);
            jsonfile.writeFile.yields(null);

            cloneISPUtil.downloadISPFiles(ispIdList, skillProjectPath, profile, null, (error) => {
                expect(error).to.equal('Failed to download in-skill product(s): ' + errorMessage);
            });
            clock.tick(6000); //Wait for it
        });
        it('| Fails when callGetISP callback with errors', () => {
            const clock = sandbox.useFakeTimers();
            const ispIdList = ['isp_id_1', 'isp_id_2', 'isp_id_3'];
            const getISPResponseList = [
                {
                    inSkillProductDefinition: {
                        referenceName: 'isp_name_1',
                        type: ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT
                    }
                },
                {
                    inSkillProductDefinition: {
                        referenceName: 'isp_name_2',
                        type: ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT
                    }
                },
                {
                    inSkillProductDefinition: {
                        referenceName: 'isp_name_3',
                        type: ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT
                    }
                }
            ];
            const eTagList = ['eTag1', 'eTag2', 'eTag3'];
            /**
             * Mocks
             */
            fs.existsSync.returns(false);
            const errorMessage = 'Internal Server Errors';
            apiWrapper.callGetISP.withArgs(ispIdList[0], ispConstant.ISP_STAGE.DEVELOPMENT, false, profile, null).yields(errorMessage);
            apiWrapper.callGetISP.withArgs(ispIdList[1], ispConstant.ISP_STAGE.DEVELOPMENT, false, profile, null).yields(null, getISPResponseList[1], eTagList[1]);
            apiWrapper.callGetISP.withArgs(ispIdList[2], ispConstant.ISP_STAGE.DEVELOPMENT, false, profile, null).yields(null, getISPResponseList[2], eTagList[2]);
            mkdirp.mkdirP.yields(null);
            jsonfile.writeFile.yields(null);
            cloneISPUtil.downloadISPFiles(ispIdList, skillProjectPath, profile, null, (error) => {
                expect(error).to.equal('Failed to download in-skill product(s): ' + errorMessage);
            });
            clock.tick(6000); //Wait for it
        });
        it('| Fails when callGetISP callback with no ISP definition', () => {
            const clock = sandbox.useFakeTimers();
            const ispIdList = ['isp_id_1', 'isp_id_2', 'isp_id_3'];
            const getISPResponseList = [
                {
                    inSkillProductDefinition: {
                        referenceName: 'isp_name_1',
                        type: ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT
                    }
                },
                {
                    inSkillProductDefinition: {
                        referenceName: 'isp_name_2',
                        type: ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT
                    }
                },
                {
                    inSkillProductDefinition: {
                        referenceName: 'isp_name_3',
                        type: ispConstant.ISP_PRODUCT_TYPE.ENTITLEMENT
                    }
                }
            ];
            const eTagList = ['eTag1', 'eTag2', 'eTag3'];
            /**
             * Mocks
             */
            fs.existsSync.returns(false);
            apiWrapper.callGetISP.withArgs(ispIdList[0], ispConstant.ISP_STAGE.DEVELOPMENT, false, profile, null).yields(null,{});
            apiWrapper.callGetISP.withArgs(ispIdList[1], ispConstant.ISP_STAGE.DEVELOPMENT, false, profile, null).yields(null, getISPResponseList[1], eTagList[1]);
            apiWrapper.callGetISP.withArgs(ispIdList[2], ispConstant.ISP_STAGE.DEVELOPMENT, false, profile, null).yields(null, getISPResponseList[2], eTagList[2]);
            mkdirp.mkdirP.yields(null);
            jsonfile.writeFile.yields(null);
            cloneISPUtil.downloadISPFiles(ispIdList, skillProjectPath, profile, null, (error) => {
                expect(error).to.equal('Failed to download in-skill product(s): ' + 'Cannot get in-skill product definition from the response from getISP service');
            });
            clock.tick(6000); //Wait for it
        });
    });
});