'use strict';

const expect = require('chai').expect;
const sinon = require('sinon');
const fs = require('fs');
const deployISP = require('../../lib/deploy/deploy-isp');
const ispUtil = require('../../lib/utils/isp-utils/isp-utility');
const ispConstant = require('../../lib/utils/isp-utils/isp-constants');
const jsonfile = require('jsonfile');
const displayUtil = require('../../lib/utils/display-utility');
const apiWrapper = require('../../lib/api/api-wrapper');

describe('Deploy ISP testing', () => {
    describe('# test getISPDeployCollections', () => {
        let sandbox;
        beforeEach(() => {
            sandbox = sinon.sandbox.create();
            sandbox.stub(ispUtil, 'getISPConfigs');
            sandbox.stub(fs, 'existsSync');
            sandbox.stub(jsonfile, 'readFileSync');
        });

        afterEach(() => {
            sandbox.restore();
        });

        it('| Succeed to return a collection of ISP to be deployed', () => {
            fs.existsSync.returns(true);
            jsonfile.readFileSync.returns({
                purchasableState: ispConstant.ISP_PURCHASABLE_STATE.PURCHASABLE
            });
            const ispToAddWithFileConfig = {
                filePath: 'isp_file_1',
                deploy_status: ispConstant.DEPLOY_STATUS.ADD
            };
            const ispToAssociateConfig = {
                productId: 'isp_id_3',
                filePath: 'isp_file_3',
                deploy_status: ispConstant.DEPLOY_STATUS.ASSOCIATE
            };
            const ispToUpdateConfig = {
                productId: 'isp_id_4',
                filePath: 'isp_file_4',
                deploy_status: ispConstant.DEPLOY_STATUS.UPDATE
            };
            const ispToRemoveConfig = {
                productId: 'isp_id_5',
                filePath: 'isp_file_5',
                deploy_status: ispConstant.DEPLOY_STATUS.REMOVE
            };
            ispUtil.getISPConfigs.returns(
                [
                    ispToAddWithFileConfig,
                    ispToAssociateConfig,
                    ispToUpdateConfig,
                    ispToRemoveConfig
                ]
            );
            deployISP.getISPDeployCollections('foo', true, 'foo', (error, deployCollections) => {
                expect(error).to.equal(null);
                expect(!deployCollections).to.equal(false);
                expect(deployCollections.create).to.eql([ispToAddWithFileConfig]);
                expect(deployCollections.associate).to.eql([ispToAssociateConfig]);
                expect(deployCollections.update).to.eql([ispToUpdateConfig]);
                expect(deployCollections.disassociate).to.eql([ispToRemoveConfig]);
            });
        });

        it(' | Callback with error when the skill path does not exit', () => {
            const skillProjectPath = 'skill_path';
            fs.existsSync.withArgs(skillProjectPath).returns(false);
            deployISP.getISPDeployCollections(skillProjectPath, true, 'foo', (error) => {
                expect(error).to.equal('Failed to get in-skill product deployment settings since the skill project path is invalid.');
            });
        });

        it(' | Error list in the deploy collection contains error info when the file does not exit for the ISP that is marked as Add', () => {
            const skillProjectPath = 'skill_path';
            const ispToAddWithFileConfig = {
                filePath: 'isp_file_1',
                deploy_status: ispConstant.DEPLOY_STATUS.ADD
            };
            fs.existsSync.withArgs(skillProjectPath).returns(true);
            fs.existsSync.withArgs(ispToAddWithFileConfig.filePath).returns(false);
            ispUtil.getISPConfigs.returns(
                [
                    ispToAddWithFileConfig
                ]
            );
            deployISP.getISPDeployCollections(skillProjectPath, true, 'foo', (error, deployCollections) => {
                expect(error).to.equal(null);
                expect(deployCollections.error).to.eql([{
                    filePath: ispToAddWithFileConfig.filePath,
                    deploy_status: ispToAddWithFileConfig.deploy_status,
                    error: ispConstant.ERROR.INVALID_CONFIG_MISSING_FILE
                }]);
            });
        });

        it(' | Error list in the deploy collection contains error info when the file does not exit for the ISP that is marked as Associate', () => {
            const skillProjectPath = 'skill_path';
            const ispToAssociate = {
                filePath: 'isp_file_1',
                productId: 'isp_id_1',
                deploy_status: ispConstant.DEPLOY_STATUS.ASSOCIATE
            };
            fs.existsSync.withArgs(skillProjectPath).returns(true);
            fs.existsSync.withArgs(ispToAssociate.filePath).returns(false);
            ispUtil.getISPConfigs.returns(
                [
                    ispToAssociate
                ]
            );
            deployISP.getISPDeployCollections(skillProjectPath, true, 'foo', (error, deployCollections) => {
                expect(error).to.equal(null);
                expect(deployCollections.error).to.eql([{
                    filePath: ispToAssociate.filePath,
                    productId: ispToAssociate.productId,
                    deploy_status: ispToAssociate.deploy_status,
                    error: ispConstant.ERROR.INVALID_CONFIG_MISSING_FILE
                }]);
            });
        });

        it(' | Error list in the deploy collection contains error info when the product id does not exit for the ISP that is marked as Associate', () => {
            const skillProjectPath = 'skill_path';
            const ispToAssociate = {
                filePath: 'isp_file',
                deploy_status: ispConstant.DEPLOY_STATUS.ASSOCIATE
            };
            fs.existsSync.withArgs(skillProjectPath).returns(true);
            fs.existsSync.withArgs(ispToAssociate.filePath).returns(true);
            jsonfile.readFileSync.returns({
                purchasableState: ispConstant.ISP_PURCHASABLE_STATE.PURCHASABLE
            });
            ispUtil.getISPConfigs.returns(
                [
                    ispToAssociate
                ]
            );
            deployISP.getISPDeployCollections(skillProjectPath, true, 'foo', (error, deployCollections) => {
                expect(error).to.equal(null);
                expect(deployCollections.error).to.eql([{
                    filePath: ispToAssociate.filePath,
                    deploy_status: ispToAssociate.deploy_status,
                    error: ispConstant.ERROR.INVALID_CONFIG_MISSING_ID
                }]);
            });
        });

        it(' | Error list in the deploy collection contains error info when the file does not exit for the ISP that is marked as updating', () => {
            const skillProjectPath = 'skill_path';
            const ispToUpdate = {
                filePath: 'isp_file_1',
                productId: 'isp_id_1',
                deploy_status: ispConstant.DEPLOY_STATUS.UPDATE
            };
            fs.existsSync.withArgs(skillProjectPath).returns(true);
            fs.existsSync.withArgs(ispToUpdate.filePath).returns(false);
            ispUtil.getISPConfigs.returns(
                [
                    ispToUpdate
                ]
            );
            deployISP.getISPDeployCollections(skillProjectPath, true, 'foo', (error, deployCollections) => {
                expect(error).to.equal(null);
                expect(deployCollections.error).to.eql([{
                    filePath: ispToUpdate.filePath,
                    productId: ispToUpdate.productId,
                    deploy_status: ispToUpdate.deploy_status,
                    error: ispConstant.ERROR.INVALID_CONFIG_MISSING_FILE
                }]);
            });
        });

        it(' | Error list in the deploy collection contains error info when the product id does not exit for the ISP that is marked as updating', () => {
            const skillProjectPath = 'skill_path';
            const ispToUpdate = {
                filePath: 'isp_file_1',
                deploy_status: ispConstant.DEPLOY_STATUS.UPDATE
            };
            fs.existsSync.withArgs(skillProjectPath).returns(true);
            fs.existsSync.withArgs(ispToUpdate.filePath).returns(true);
            jsonfile.readFileSync.returns({
                purchasableState: ispConstant.ISP_PURCHASABLE_STATE.PURCHASABLE
            });
            ispUtil.getISPConfigs.returns(
                [
                    ispToUpdate
                ]
            );
            deployISP.getISPDeployCollections(skillProjectPath, true, 'foo', (error, deployCollections) => {
                expect(error).to.equal(null);
                expect(deployCollections.error).to.eql([{
                    filePath: ispToUpdate.filePath,
                    deploy_status: ispToUpdate.deploy_status,
                    error: ispConstant.ERROR.INVALID_CONFIG_MISSING_ID
                }]);
            });
        });

        it(' | Error list in the deploy collection contains error info when the purchasable state is not valid', () => {
            const skillProjectPath = 'skill_path';
            const ispToUpdate = {
                productId: 'isp_product_id',
                filePath: 'isp_file_1',
                deploy_status: ispConstant.DEPLOY_STATUS.UPDATE
            };
            fs.existsSync.withArgs(skillProjectPath).returns(true);
            fs.existsSync.withArgs(ispToUpdate.filePath).returns(true);
            jsonfile.readFileSync.returns({
                purchasableState: 'No'
            });
            ispUtil.getISPConfigs.returns(
                [
                    ispToUpdate
                ]
            );
            deployISP.getISPDeployCollections(skillProjectPath, true, 'foo', (error, deployCollections) => {
                expect(error).to.equal(null);
                expect(deployCollections.error).to.eql([{
                    productId: ispToUpdate.productId,
                    filePath: ispToUpdate.filePath,
                    deploy_status: ispToUpdate.deploy_status,
                    error: ispConstant.ERROR.INVALID_ISP_PURCHASABLE_STATE
                }]);
            });
        });
    });

    describe('# test deployISPProcess', () => {
        let sandbox;
        let mockSpinner;
        before(() => {
            mockSpinner = displayUtil.Spinner();
        });
        beforeEach(() => {
            sandbox = sinon.sandbox.create();
            sandbox.stub(fs, 'existsSync');
            sandbox.stub(ispUtil, 'getISPConfigs');
            sandbox.stub(displayUtil, 'Spinner', () => {
                return mockSpinner;
            });
            sandbox.stub(mockSpinner, 'start');
            sandbox.stub(jsonfile, 'readFile');
            sandbox.stub(jsonfile, 'readFileSync');
        });

        afterEach(() => {
            sandbox.restore();
        });

        it(' | Succeed to update in-skill products', () => {
            sandbox.stub(apiWrapper, 'callUpdateISP');
            const clock = sandbox.useFakeTimers();
            const updateISPConfig = {
                filePath: 'isp_file_path',
                productId: 'isp_product_id',
                deploy_status: ispConstant.DEPLOY_STATUS.UPDATE
            };

            fs.existsSync.returns(true);
            jsonfile.readFileSync.returns({
                purchasableState: ispConstant.ISP_PURCHASABLE_STATE.PURCHASABLE
            });
            ispUtil.getISPConfigs.returns([
                updateISPConfig
            ]);
            jsonfile.readFile.yields(null, {
                type: 'ENTITLEMENT'
            });
            apiWrapper.callUpdateISP.yields(null);

            deployISP.deployISPProcess('foo', 'foo', true, 'foo', false, (error, ispConfigList, deployedISPs) => {
                expect(error).to.equal(null);
                expect(ispConfigList).to.eql([updateISPConfig]);
                expect(deployedISPs.updated).to.eql([{
                    productId: updateISPConfig.productId,
                    filePath: updateISPConfig.filePath,
                    deploy_status: ispConstant.DEPLOY_STATUS.UPDATE
                }]);
            });
            clock.tick(6000); //wait for it
        });

        it(' | Error when updating in-skill products with invalid json file', () => {
            sandbox.stub(apiWrapper, 'callUpdateISP');
            const clock = sandbox.useFakeTimers();
            const updateISPConfig = {
                filePath: 'isp_file_path',
                productId: 'isp_product_id',
                deploy_status: ispConstant.DEPLOY_STATUS.UPDATE
            };

            fs.existsSync.returns(true);
            jsonfile.readFileSync.returns({
                purchasableState: ispConstant.ISP_PURCHASABLE_STATE.PURCHASABLE
            });
            ispUtil.getISPConfigs.returns([
                updateISPConfig
            ]);
            jsonfile.readFile.yields(null, null);
            apiWrapper.callUpdateISP.yields(null);

            deployISP.deployISPProcess('foo', 'foo', true, 'foo', false, (error, ispConfigList) => {
                expect(!error).to.equal(false);
                expect(error.message).to.equal('Failed to update in-skill product(s)');
                expect(error.errorList).to.eql([{
                    apiName: ispConstant.API.UPDATE_ISP,
                    filePath: updateISPConfig.filePath,
                    productId: updateISPConfig.productId,
                    error: ispConstant.ERROR.INVALID_ISP_FILE
                }]);
                expect(ispConfigList).to.eql([updateISPConfig]);
            });
            clock.tick(6000); //wait for it
        });

        it(' | Error when updating in-skill products with updateISP api error', () => {
            sandbox.stub(apiWrapper, 'callUpdateISP');
            const clock = sandbox.useFakeTimers();
            const updateISPConfig = {
                filePath: 'isp_file_path',
                productId: 'isp_product_id',
                deploy_status: ispConstant.DEPLOY_STATUS.UPDATE
            };

            fs.existsSync.returns(true);
            jsonfile.readFileSync.returns({
                purchasableState: ispConstant.ISP_PURCHASABLE_STATE.PURCHASABLE
            });
            ispUtil.getISPConfigs.returns([
                updateISPConfig
            ]);
            jsonfile.readFile.yields(null, {
                type: 'ENTITLEMENT'
            });
            const errorMessage = 'service error';
            apiWrapper.callUpdateISP.yields(errorMessage);

            deployISP.deployISPProcess('foo', 'foo', true, 'foo', false, (error, ispConfigList) => {
                expect(!error).to.equal(false);
                expect(error.message).to.equal('Failed to update in-skill product(s)');
                expect(error.errorList).to.eql([{
                    apiName: ispConstant.API.UPDATE_ISP,
                    filePath: updateISPConfig.filePath,
                    productId: updateISPConfig.productId,
                    error: errorMessage
                }]);
                expect(ispConfigList).to.eql([updateISPConfig]);
            });
            clock.tick(6000); //wait for it
        });

        it(' | Succeed to create and associate in-skill products', () => {
            sandbox.stub(apiWrapper, 'callCreateISP');
            sandbox.stub(apiWrapper, 'callAssociateISP');
            const clock = sandbox.useFakeTimers();
            const productId = 'isp_product_id';
            const createISPConfig = {
                filePath: 'isp_file_path',
                deploy_status: ispConstant.DEPLOY_STATUS.ADD
            };

            fs.existsSync.returns(true);
            ispUtil.getISPConfigs.returns([
                createISPConfig
            ]);
            jsonfile.readFile.yields(null, {
                type: 'ENTITLEMENT'
            });
            jsonfile.readFileSync.returns({
                purchasableState: ispConstant.ISP_PURCHASABLE_STATE.PURCHASABLE
            });
            apiWrapper.callCreateISP.yields(null, {
                productId: productId
            });
            apiWrapper.callAssociateISP.yields(null);

            deployISP.deployISPProcess('foo', 'foo', false, 'foo', false, (error, ispConfigList, deployedISPs) => {
                expect(error).to.equal(null);
                expect(ispConfigList).to.eql([{
                    productId: productId,
                    filePath: createISPConfig.filePath,
                    deploy_status: ispConstant.DEPLOY_STATUS.UPDATE
                }]);
                expect(deployedISPs.created).to.eql([{
                    productId: productId,
                    filePath: createISPConfig.filePath,
                    deploy_status: ispConstant.DEPLOY_STATUS.ASSOCIATE
                }]);
                expect(deployedISPs.associated).to.eql([{
                    productId: productId,
                    filePath: createISPConfig.filePath,
                    deploy_status: ispConstant.DEPLOY_STATUS.UPDATE
                }]);
            });

            clock.tick(6000); //wait for it
        });

        it(' | Error when creating in-skill products with invalid json file', () => {
            sandbox.stub(apiWrapper, 'callCreateISP');
            sandbox.stub(apiWrapper, 'callAssociateISP');
            const clock = sandbox.useFakeTimers();
            const productId = 'isp_product_id';
            const createISPConfig = {
                filePath: 'isp_file_path',
                deploy_status: ispConstant.DEPLOY_STATUS.ADD
            };

            fs.existsSync.returns(true);
            ispUtil.getISPConfigs.returns([
                createISPConfig
            ]);
            jsonfile.readFile.yields(null, null);
            jsonfile.readFileSync.returns({
                purchasableState: ispConstant.ISP_PURCHASABLE_STATE.PURCHASABLE
            });
            apiWrapper.callCreateISP.yields(null, {
                productId: productId
            });
            apiWrapper.callAssociateISP.yields(null);

            deployISP.deployISPProcess('foo', 'foo', true, 'foo', false, (error, ispConfigList) => {
                expect(!error).to.equal(false);
                expect(error.message).to.equal('Failed to create in-skill product(s)');
                expect(error.errorList).to.eql([{
                    apiName: ispConstant.API.CREATE_ISP,
                    filePath: createISPConfig.filePath,
                    error: ispConstant.ERROR.INVALID_ISP_FILE
                }]);
                expect(ispConfigList).to.eql([createISPConfig]);
            });

            clock.tick(6000); //wait for it
        });

        it(' | Error when creating in-skill products with createISP service error', () => {
            sandbox.stub(apiWrapper, 'callCreateISP');
            sandbox.stub(apiWrapper, 'callAssociateISP');
            const clock = sandbox.useFakeTimers();
            const createISPConfig = {
                filePath: 'isp_file_path',
                deploy_status: ispConstant.DEPLOY_STATUS.ADD
            };

            fs.existsSync.returns(true);
            ispUtil.getISPConfigs.returns([
                createISPConfig
            ]);
            jsonfile.readFile.yields(null, {
                type: 'ENTITLEMENT'
            });
            jsonfile.readFileSync.returns({
                purchasableState: ispConstant.ISP_PURCHASABLE_STATE.PURCHASABLE
            });
            const errorMessage = 'service error';
            apiWrapper.callCreateISP.yields(errorMessage);
            apiWrapper.callAssociateISP.yields(null);

            deployISP.deployISPProcess('foo', 'foo', true, 'foo', false, (error, ispConfigList) => {
                expect(!error).to.equal(false);
                expect(error.message).to.equal('Failed to create in-skill product(s)');
                expect(error.errorList).to.eql([{
                    apiName: ispConstant.API.CREATE_ISP,
                    filePath: createISPConfig.filePath,
                    error: errorMessage
                }]);
                expect(ispConfigList).to.eql([createISPConfig]);
            });

            clock.tick(6000); //wait for it
        });

        it(' | Error when creating in-skill products with createISP does not contains productId ', () => {
            sandbox.stub(apiWrapper, 'callCreateISP');
            sandbox.stub(apiWrapper, 'callAssociateISP');
            const clock = sandbox.useFakeTimers();
            const createISPConfig = {
                filePath: 'isp_file_path',
                deploy_status: ispConstant.DEPLOY_STATUS.ADD
            };

            fs.existsSync.returns(true);
            ispUtil.getISPConfigs.returns([
                createISPConfig
            ]);
            jsonfile.readFile.yields(null, {
                type: 'ENTITLEMENT'
            });
            jsonfile.readFileSync.returns({
                purchasableState: ispConstant.ISP_PURCHASABLE_STATE.PURCHASABLE
            });
            apiWrapper.callCreateISP.yields(null, null);
            apiWrapper.callAssociateISP.yields(null);

            deployISP.deployISPProcess('foo', 'foo', true, 'foo', false, (error, ispConfigList) => {
                expect(!error).to.equal(false);
                expect(error.message).to.equal('Failed to create in-skill product(s)');
                expect(error.errorList).to.eql([{
                    apiName: ispConstant.API.CREATE_ISP,
                    filePath: createISPConfig.filePath,
                    error: 'Cannot get in-skill product Id from service response'
                }]);
                expect(ispConfigList).to.eql([createISPConfig]);
            });

            clock.tick(6000); //wait for it
        });

        it(' | Error when associating in-skill products with associateISP service error', () => {
            sandbox.stub(apiWrapper, 'callCreateISP');
            sandbox.stub(apiWrapper, 'callAssociateISP');
            const clock = sandbox.useFakeTimers();
            const createISPConfig = {
                filePath: 'isp_file_path',
                deploy_status: ispConstant.DEPLOY_STATUS.ADD
            };

            fs.existsSync.returns(true);
            ispUtil.getISPConfigs.returns([
                createISPConfig
            ]);
            jsonfile.readFile.yields(null, {
                type: 'ENTITLEMENT'
            });
            jsonfile.readFileSync.returns({
                purchasableState: ispConstant.ISP_PURCHASABLE_STATE.PURCHASABLE
            });
            const errorMessage = 'service error';
            const productId = 'isp_product_id';
            apiWrapper.callCreateISP.yields(null, {
                productId: productId
            });
            apiWrapper.callAssociateISP.yields(errorMessage);

            deployISP.deployISPProcess('foo', 'foo', true, 'foo', false, (error, ispConfigList) => {
                expect(!error).to.equal(false);
                expect(error.message).to.equal('Failed to associate in-skill product(s)');
                expect(error.errorList).to.eql([{
                    apiName: ispConstant.API.ASSOCIATE_ISP,
                    filePath: createISPConfig.filePath,
                    productId: productId,
                    error: errorMessage
                }]);
                expect(ispConfigList).to.eql([{
                    filePath: createISPConfig.filePath,
                    productId: productId,
                    deploy_status: ispConstant.DEPLOY_STATUS.ASSOCIATE
                }]);
            });

            clock.tick(6000); //wait for it
        });

        it(' | Succeed to associate an in-skill products', () => {
            sandbox.stub(apiWrapper, 'callUpdateISP');
            sandbox.stub(apiWrapper, 'callAssociateISP');
            const clock = sandbox.useFakeTimers();
            const productId = 'isp_product_id';
            const filePath = 'isp_file_path';
            const associateISPConfig = {
                productId: productId,
                filePath: filePath,
                deploy_status: ispConstant.DEPLOY_STATUS.ASSOCIATE
            };

            fs.existsSync.returns(true);
            ispUtil.getISPConfigs.returns([
                associateISPConfig
            ]);
            jsonfile.readFile.yields(null, {
                type: 'ENTITLEMENT'
            });
            jsonfile.readFileSync.returns({
                purchasableState: ispConstant.ISP_PURCHASABLE_STATE.PURCHASABLE
            });
            apiWrapper.callUpdateISP.yields(null);
            const associatedISPConfig = {
                productId: productId,
                filePath: filePath,
                deploy_status: ispConstant.DEPLOY_STATUS.UPDATE
            };
            apiWrapper.callAssociateISP.yields(null);

            deployISP.deployISPProcess('foo', 'foo', true, 'foo', false, (error, ispConfigList, deployedISPs) => {
                expect(error).to.equal(null);
                expect(ispConfigList).to.eql([associatedISPConfig]);
                expect(deployedISPs.associated).to.eql([{
                    filePath: filePath,
                    productId: productId,
                    deploy_status: ispConstant.DEPLOY_STATUS.UPDATE
                }]);
            });

            clock.tick(6000); //wait for it
        });

        it(' | Error when associate an ISP but the update before association fails', () => {
            sandbox.stub(apiWrapper, 'callUpdateISP');
            sandbox.stub(apiWrapper, 'callAssociateISP');
            const clock = sandbox.useFakeTimers();
            const productId = 'isp_product_id';
            const filePath = 'isp_file_path';
            const associateISPConfig = {
                productId: productId,
                filePath: filePath,
                deploy_status: ispConstant.DEPLOY_STATUS.ASSOCIATE
            };

            fs.existsSync.returns(true);
            ispUtil.getISPConfigs.returns([
                associateISPConfig
            ]);
            jsonfile.readFile.yields(null, {
                type: 'ENTITLEMENT'
            });
            jsonfile.readFileSync.returns({
                purchasableState: ispConstant.ISP_PURCHASABLE_STATE.PURCHASABLE
            });
            const errorMessage = 'service error';
            apiWrapper.callUpdateISP.yields(errorMessage);
            apiWrapper.callAssociateISP.yields(null);

            deployISP.deployISPProcess('foo', 'foo', true, 'foo', false, (error, ispConfigList) => {
                expect(!error).to.equal(false);
                expect(error.message).to.equal('Failed to update in-skill product(s)');
                expect(error.errorList).to.eql([{
                    apiName: ispConstant.API.UPDATE_ISP,
                    filePath: associateISPConfig.filePath,
                    productId: associateISPConfig.productId,
                    error: errorMessage
                }]);
                expect(ispConfigList).to.eql([associateISPConfig]);
            });

            clock.tick(6000); //wait for it
        });

        it(' | Succeed to disassociate in-skill products', () => {
            sandbox.stub(apiWrapper, 'callDisassociateISP');
            sandbox.stub(fs, 'unlinkSync');
            const clock = sandbox.useFakeTimers();
            const productId = 'isp_product_id';
            const removeISPConfig = {
                filePath: 'isp_file_path',
                productId: productId,
                deploy_status: ispConstant.DEPLOY_STATUS.REMOVE
            };

            fs.existsSync.returns(true);
            fs.unlinkSync.returns(true);
            ispUtil.getISPConfigs.returns([
                removeISPConfig
            ]);
            jsonfile.readFileSync.returns({
                purchasableState: ispConstant.ISP_PURCHASABLE_STATE.PURCHASABLE
            });
            apiWrapper.callDisassociateISP.yields(null);

            deployISP.deployISPProcess('foo', 'foo', true, 'foo', false, (error, ispConfigList, deployedISPs) => {
                expect(error).to.equal(null);
                expect(ispConfigList.length).to.equal(0);
                expect(deployedISPs.removed).to.eql([{
                    productId: productId,
                    filePath: removeISPConfig.filePath,
                    deploy_status: ispConstant.DEPLOY_STATUS.REMOVE
                }]);
            });
            clock.tick(6000); //wait for it
        });
        it(' | Error when disassociating in-skill products with disassociateISP service error', () => {
            sandbox.stub(apiWrapper, 'callDisassociateISP');
            sandbox.stub(fs, 'unlinkSync');
            const clock = sandbox.useFakeTimers();
            const productId = 'isp_product_id';
            const removeISPConfig = {
                filePath: 'isp_file_path',
                productId: productId,
                deploy_status: ispConstant.DEPLOY_STATUS.REMOVE
            };

            fs.existsSync.returns(true);
            fs.unlinkSync.returns(true);
            ispUtil.getISPConfigs.returns([
                removeISPConfig
            ]);
            jsonfile.readFileSync.returns({
                purchasableState: ispConstant.ISP_PURCHASABLE_STATE.PURCHASABLE
            });
            const errorMessage = 'service error';
            apiWrapper.callDisassociateISP.yields(errorMessage);

            deployISP.deployISPProcess('foo', 'foo', true, 'foo', false, (error, ispConfigList) => {
                expect(!error).to.equal(false);
                expect(error.message).to.equal('Failed to remove in-skill product(s)');
                expect(error.errorList).to.eql([{
                    apiName: ispConstant.API.DISASSOCIATE_ISP,
                    filePath: removeISPConfig.filePath,
                    productId: removeISPConfig.productId,
                    error: errorMessage
                }]);
                expect(ispConfigList).to.eql([removeISPConfig]);
            });
            clock.tick(6000); //wait for it
        });

        /**
         * Mixed cases
         */
        it(' | Succeed to create, associate, update and remove ISPs', () => {
            sandbox.stub(apiWrapper, 'callCreateISP');
            sandbox.stub(apiWrapper, 'callUpdateISP');
            sandbox.stub(apiWrapper, 'callAssociateISP');
            sandbox.stub(apiWrapper, 'callDisassociateISP');
            sandbox.stub(fs, 'unlinkSync');
            const clock = sandbox.useFakeTimers();
            const createISPConfig = {
                filePath: 'isp_file_path_1',
                deploy_status: ispConstant.DEPLOY_STATUS.ADD
            };
            const associateISPConfig = {
                filePath: 'isp_file_path_2',
                productId: 'isp_id_2',
                deploy_status: ispConstant.DEPLOY_STATUS.ASSOCIATE
            };
            const updateISPConfig = {
                filePath: 'isp_file_path_3',
                productId: 'isp_id_3',
                deploy_status: ispConstant.DEPLOY_STATUS.UPDATE
            };
            const removeISPConfig = {
                filePath: 'isp_file_path_4',
                productId: 'isp_id_4',
                deploy_status: ispConstant.DEPLOY_STATUS.REMOVE
            };

            fs.existsSync.returns(true);
            fs.unlinkSync.returns(true);

            fs.existsSync.returns(true);
            ispUtil.getISPConfigs.returns([
                createISPConfig
            ]);
            jsonfile.readFile.yields(null, {
                type: 'ENTITLEMENT'
            });
            ispUtil.getISPConfigs.returns([
                createISPConfig,
                updateISPConfig,
                associateISPConfig,
                removeISPConfig
            ]);
            jsonfile.readFileSync.returns({
                purchasableState: ispConstant.ISP_PURCHASABLE_STATE.PURCHASABLE
            });

            apiWrapper.callCreateISP.yields(null, {
                productId: 'isp_id_1'
            });
            apiWrapper.callUpdateISP.yields(null);
            apiWrapper.callAssociateISP.yields(null);
            apiWrapper.callDisassociateISP.yields(null);

            const compareIspConfig = (a, b) => {
                return (a.productId < b.productId ? -1 : (a.productId > b.productId ? 1 : 0));
            };
            deployISP.deployISPProcess('foo', 'foo', true, 'foo', false, (error, ispConfigList) => {
                expect(ispConfigList.sort(compareIspConfig)).to.eql([
                    {
                        filePath: 'isp_file_path_1',
                        productId: 'isp_id_1',
                        deploy_status: ispConstant.DEPLOY_STATUS.UPDATE
                    },
                    {
                        filePath: 'isp_file_path_2',
                        productId: 'isp_id_2',
                        deploy_status: ispConstant.DEPLOY_STATUS.UPDATE
                    },
                    {
                        filePath: 'isp_file_path_3',
                        productId: 'isp_id_3',
                        deploy_status: ispConstant.DEPLOY_STATUS.UPDATE
                    }].sort(compareIspConfig));
            });
            clock.tick(6000); //wait for it
        });
    });
});