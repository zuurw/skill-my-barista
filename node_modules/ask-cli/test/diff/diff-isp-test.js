'use strict';

const expect = require('chai').expect;
const sinon = require('sinon');
const fs = require('fs');
const jsonfile = require('jsonfile');
const jsdiff = require('diff');

const cloneIspUtil = require('../../lib/clone/clone-isp');
const ispConstants = require('../../lib/utils/isp-utils/isp-constants');
const deployIspUtil = require('../../lib/deploy/deploy-isp');
const diffIspUtil = require('../../lib/diff/diff-isp');
const constants = require('../../lib/utils/constants');

describe('Diff ISP testing', () => {
    describe('# test diff', () => {
        let sandbox;
        beforeEach(() => {
            sandbox = sinon.sandbox.create();
            sandbox.stub(deployIspUtil, 'getISPDeployCollections');
            sandbox.stub(fs, 'existsSync');
            sandbox.stub(cloneIspUtil, 'getISPFromSkill');
            sandbox.stub(jsonfile, 'readFile');
        });

        afterEach(() => {
            sandbox.restore();
        });
        const ispToUpdateConfig
            = {
            productId: 'isp_id_1',
            filePath: 'isp_file_1',
            deploy_status: ispConstants.DEPLOY_STATUS.UPDATE,
            eTag: 'etag_1'
        };
        const localDefinition = {referenceName: 'foo'};
        const remoteIspInfo = {
            productId: 'isp_id_1',
            definition: {
                referenceName: 'foo_1'
            },
            eTag: 'etat_1_1'
        };
        it('| Succeed to diff ISPs', () => {
            const clock = sandbox.useFakeTimers();
            fs.existsSync.returns(true);
            deployIspUtil.getISPDeployCollections.yields(null, {
                update: [ispToUpdateConfig],
                disassociate: [],
                create: [],
                associate: []
            });

            const remoteIspInfoMap = new Map();
            remoteIspInfoMap.set(ispToUpdateConfig
                .productId, remoteIspInfo);
            cloneIspUtil.getISPFromSkill.yields(null, remoteIspInfoMap);


            jsonfile.readFile.yields(null, localDefinition);

            diffIspUtil.diff('foo', 'foo', null, 'default', (diffIspError, diffIspResultsMap) => {
                expect(diffIspError).to.equal(null);
                expect(diffIspResultsMap.get(ispToUpdateConfig
                    .productId)).to.eql({
                    isLatest: false,
                    filePath: ispToUpdateConfig
                        .filePath,
                    diff: jsdiff.createTwoFilesPatch(
                        constants.DIFF.DIFF_DISPLAY.ISP_OLD_NAME_PREFIX + ispToUpdateConfig
                            .filePath,
                        constants.DIFF.DIFF_DISPLAY.ISP_NEW_NAME_PREFIX + ispToUpdateConfig
                            .filePath,
                        JSON.stringify(localDefinition, null, 2),
                        JSON.stringify(remoteIspInfo.definition, null, 2),
                        constants.DIFF.DIFF_DISPLAY.OLD_HEADER,
                        constants.DIFF.DIFF_DISPLAY.NEW_HEADER,
                        {
                            context: constants.DIFF.DIFF_DISPLAY.CONTEXT_NUMBER
                        }
                    ),
                    existIn: constants.DIFF.RESOURCE_EXIST_IN.BOTH
                });
            });

            clock.tick(6000); //wait for it
        });
        it('| Fail to diff ISPs when skill path is invalid', () => {
            diffIspUtil.diff('foo', 'foo', null, 'default', (diffIspError, diffIspResultsMap) => {
                expect(diffIspError).to.equal('Invalid skill project path.');
                expect(!diffIspResultsMap).to.equal(true);
            });
        });
        it('| Fail to diff ISPs when user profile is missing', () => {
            fs.existsSync.returns(true);
            diffIspUtil.diff('foo', 'foo', null, null, (diffIspError, diffIspResultsMap) => {
                expect(diffIspError).to.equal(ispConstants.ERROR.MISSING_USER_PROFILE);
                expect(!diffIspResultsMap).to.equal(true);
            });
        });
        it('| Fail to diff ISPs when deployCollectionsError', () => {
            const error = 'Failed to get isp deploy collection';
            fs.existsSync.returns(true);
            deployIspUtil.getISPDeployCollections.yields(error);
            diffIspUtil.diff('foo', 'foo', null, 'default', (diffIspError, diffIspResultsMap) => {
                expect(diffIspError).to.equal(error);
                expect(!diffIspResultsMap).to.equal(true);
            });
        });
        it('| Return with nothing to when there is no isp', () => {
            fs.existsSync.returns(true);
            deployIspUtil.getISPDeployCollections.yields(null, {
                update: [],
                disassociate: [],
                create: [],
                associate: []
            });
            diffIspUtil.diff('foo', 'foo', null, 'default', (diffIspError, diffIspResultsMap) => {
                expect(diffIspError).to.equal(null);
                expect(!diffIspResultsMap).to.equal(true);
            });
        });

        it('| Fail to diff ISPs when getLocalISPMap callbacks with error', () => {
            fs.existsSync.returns(true);
            deployIspUtil.getISPDeployCollections.yields(null, {
                update: [ispToUpdateConfig],
                disassociate: [],
                create: [],
                associate: []
            });

            jsonfile.readFile.yields('Failed to read JSON');

            diffIspUtil.diff('foo', 'foo', null, 'default', (diffIspError, diffIspResultsMap) => {
                expect(diffIspError).to.equal('Failed to get in-skill product(s) from local project.');
                expect(!diffIspResultsMap).to.equal(true);
            });
        });

        it('| Fail to diff ISPs when getISPFromSkill callbacks with error', () => {
            const clock = sandbox.useFakeTimers();
            fs.existsSync.returns(true);
            deployIspUtil.getISPDeployCollections.yields(null, {
                update: [ispToUpdateConfig],
                disassociate: [],
                create: [],
                associate: []
            });

            const error = 'Failed to get ISP info';
            cloneIspUtil.getISPFromSkill.yields(error);


            jsonfile.readFile.yields(null, localDefinition);

            diffIspUtil.diff('foo', 'foo', null, 'default', (diffIspError, diffIspResultsMap) => {
                expect(diffIspError).to.equal(error);
                expect(!diffIspResultsMap).to.equal(true);
            });

            clock.tick(6000); //wait for it
        });
    });
});