'use strict';

const apiWrapper = require('../api/api-wrapper');
const async = require('async');
const path = require('path');
const fs = require('fs');
const mkdirp = require('mkdirp');
const jsonfile = require('jsonfile');
const getISPListForSkill = require('../api/in-skill-product').getISPListForSkill;
const ispUtil = require('../utils/isp-utils/isp-utility');
const ispConstants = require('../utils/isp-utils/isp-constants');
const displayUtil = require('../utils/display-utility');

//TODO: Improve error logging once SMAPI has the framework ready
module.exports = {
    cloneISPFromSkill: cloneISPFromSkill,
    downloadISPFiles: downloadISPFiles,
    getISPs: getISPs,
    getISPFromSkill: getISPFromSkill
};

/**
 * Get list of in-skill products associated with given skill id, clone those ISPs and
 * update skill project configuration
 * @param skillId the id of skill
 * @param skillProjectPath root path of the skill project
 * @param profile the user profile
 * @param doDebug ASK CLI debug mode
 * @param callback the callback function that handles response (error)
 */
function cloneISPFromSkill(skillId, skillProjectPath, profile, doDebug, callback) {
    const spinner = displayUtil.Spinner('Cloning in-skill product(s)...');
    spinner.start();
    getISPFromSkill(skillId, ispConstants.ISP_STAGE.DEVELOPMENT, profile, doDebug, (error, ispInfoMap) => {
        spinner.stop();
        if (error) {
            callback(error);
            return;
        }

        if (ispInfoMap.size === 0) {
            callback(null, true);
            return;
        }
        mkdirp.mkdirP(ispUtil.getISPRootPath(skillProjectPath), (mkdirpError) => {
            if (mkdirpError) {
                callback(mkdirpError);
                return;
            }
            cloneISPs(skillProjectPath, Array.from(ispInfoMap.values()), (error, clonedISPList) => {
                if (error) {
                    callback(error);
                    return;
                }
                const ispConfigList = [];
                clonedISPList.forEach(isp => {
                    isp.deploy_status = ispConstants.DEPLOY_STATUS.UPDATE;
                    ispConfigList.push(isp);
                });
                ispUtil.replaceISPConfigs(skillProjectPath, profile, ispConfigList);
                callback();
            });
        });
    });
}

/**
 * Get a list of in-skill products associated with given skill
 * @param skillId the id of skill
 * @param stage the stage of the in-skill product
 * @param profile user profile
 * @param doDebug ASK CLI debug mode
 * @param callback the callback function that handles response (error, stage, ispInfoMap)
 */
function getISPFromSkill(skillId, stage, profile, doDebug, callback) {
    getISPListForSkill(skillId, stage, profile, doDebug, (error, inSkillProductSummaryList) => {
        if (error) {
            callback(error);
            return;
        }
        
        if (inSkillProductSummaryList.length === 0) {
            callback(null, new Map());
            return;
        }

        const ispIdList = inSkillProductSummaryList.map((ispSummary) => ispSummary.productId);

        getISPs(ispIdList, profile, doDebug, (error, ispInfoMap) => {
            if (error) {
                callback(error);
                return;
            }
            callback(null, ispInfoMap);
        });
    });
}


/**
 * Get in-skill product information async by given a list of product IDs
 * @param ispIdList a list of in-skill product ID
 * @param profile   ASK CLI user profile
 * @param doDebug   ASK CLI debug mode
 * @param callback  callback to handle the response
 */
function getISPs(ispIdList, profile, doDebug, callback) {
    const ispInfoMap = new Map();
    if (!ispIdList || ispIdList.length === 0) {
        callback(null, ispInfoMap);
        return;
    }
    /**
     * Async call to get-isp API to fetch the definition of in-skill products.
     */
    async.eachSeries(
        ispIdList,
        (ispId, eachCallback) => {
            setTimeout(() => {
                apiWrapper.callGetISP(ispId, ispConstants.ISP_STAGE.DEVELOPMENT, false, profile, doDebug, (error, responseBody, eTag) => {
                    if (error) {
                        eachCallback(error);
                        return;
                    }
                    if (!responseBody || !responseBody.inSkillProductDefinition) {
                        eachCallback('Cannot get in-skill product definition from the response from getISP service');
                        return;
                    }
                    const ispInfo = {
                        productId: ispId,
                        definition: responseBody.inSkillProductDefinition,
                        eTag: eTag
                    };
                    ispInfoMap.set(ispId, ispInfo);
                    eachCallback();
                });
            }, ispConstants.NUMBERS.TIME_INTERVAL_FOR_ASYNC_REQUEST);
        },
        (error) => {
            if (error) {
                callback(error);
                return;
            }
            callback(null, ispInfoMap);
        });
}

/**
 * Clone list of in-skill products definition to JSON files in given path
 * @param skillProjectPath the path of skill project
 * @param ispInfoList a list objects that contain ISP productId, definition and eTag
 * @param callback the callback function that handles response (error, ispConfigList)
 */
function cloneISPs(skillProjectPath, ispInfoList, callback) {
    if (!skillProjectPath || !ispInfoList) {
        callback(ispConstants.ERROR.FAILED_TO_CLONE_ISP);
        return;
    }

    let ispIndex = 0;
    const clonedISPList = [];

    if (ispInfoList.length === 0) {
        callback(null, clonedISPList);
        return;
    }

    const ispRootPath = ispUtil.getISPRootPath(skillProjectPath);
    const fileNameMap = new Map();

    async.doWhilst(
        (loopCallback) => {
            const ispInfo = ispInfoList[ispIndex];
            const productId = ispInfo.productId;
            const ispDefinition = ispInfo.definition;
            const ispReferenceName = ispDefinition.referenceName;
            const ispType = ispDefinition.type;
            const clonePathSub = path.join(ispRootPath, ispType.toLowerCase());
            let fileName = ispUtil.getISPFileName(ispReferenceName, null);
            let clonePathLeaf = path.join(clonePathSub, fileName);

            mkdirp.mkdirP(clonePathSub, (mkdirpError) => {
                if (mkdirpError) {
                    loopCallback(mkdirpError);
                    return;
                }
                /**
                 * Handle if there are duplicated product reference names
                 * Products with duplicated reference names will be created as referenceName.json, referenceName_2.json...
                 */
                if (!fileNameMap.has(clonePathLeaf) && fs.existsSync(clonePathLeaf)) {
                    fileNameMap.set(clonePathLeaf, 1);
                }

                if (fileNameMap.has(clonePathLeaf)) {
                    let lastNum = fileNameMap.get(clonePathLeaf);
                    lastNum++;
                    fileNameMap.set(clonePathLeaf, lastNum);
                    fileName = ispUtil.getISPFileName(ispReferenceName, lastNum);
                    clonePathLeaf = path.join(clonePathSub, fileName);
                } else {
                    fileNameMap.set(clonePathLeaf, 1);
                }

                jsonfile.writeFile(clonePathLeaf, ispDefinition, {spaces: 2}, (writeFileError) => {
                    if (writeFileError) {
                        loopCallback(writeFileError);
                        return;
                    }
                    const isp = {
                        productId: productId,
                        filePath: path.relative(skillProjectPath, clonePathLeaf),
                        eTag: ispInfo.eTag,
                    };

                    clonedISPList.push(isp);
                    loopCallback(null, clonedISPList);
                });
            });
        },
        () => {
            ispIndex++;
            return ispIndex < ispInfoList.length;
        },
        (error, clonedISPList) => {
            if (error) {
                callback(error);
                return;
            }
            callback(null, clonedISPList);
        }
    );
}

/**
 * Download in-skill product files
 * @param ispIdList list of in-skill product ID
 * @param skillProjectPath the root path of skill project
 * @param profile the ASK CLI user profile
 * @param doDebug the ASK CLI debug mode
 * @param callback the callback to handle the response
 */
function downloadISPFiles(ispIdList, skillProjectPath, profile, doDebug, callback) {
    if (ispIdList.length === 0) {
        callback();
        return;
    }
    getISPs(ispIdList, profile, doDebug, (getISPsError, ispInfoMap) => {
        if (getISPsError) {
            callback('Failed to download in-skill product(s): ' + getISPsError);
            return;
        }
        cloneISPs(skillProjectPath, Array.from(ispInfoMap.values()), (cloneISPsError, ispInfoList) => {
            if (cloneISPsError) {
                callback('Failed to download in-skill product(s): ' + cloneISPsError);
                return;
            }
            callback(null, ispInfoList);
        });
    });
}
