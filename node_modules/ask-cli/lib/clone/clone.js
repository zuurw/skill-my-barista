'use strict';

const cloneProject = require('./clone-project');
const cloneSkill = require('./clone-skill');
const cloneModel = require('./clone-model');
const cloneLambda = require('./clone-lambda');
const cloneLocalizing = require('./clone-localizing');
const cloneISP = require('./clone-isp');
const parser = require('../utils/skill-parser');
const path = require('path');
const profileHelper = require('../utils/profile-helper');
const sugar = require('sugar');
const inquirer = require('inquirer');
const getSkillList = require('../api/skill').getSkillList;
const CONSTANTS = require('../utils/constants');
const ispUtil = require('../utils/isp-utils/isp-utility');
const cloneStatusCheck = require('./clone-status-check');
const LIST_SKILL_PAGE_SIZE = 15;

module.exports = {
    createCommand: (commander) => {
        commander
            .command('clone')
            .description('clone an existing skill project on your computer')
            .option('-s, --skill-id <skill-id>', 'skill-id for the skill')
            .option('-p, --profile <profile>', 'ask cli profile')
            .option('-f, --force', 'force to download skill package regardless of the building status')
            .option('--debug', 'ask cli debug mode')
            .option('-h, --help', 'output usage information', () => {
                console.log(CONSTANTS.COMMAND.CLONE.HELP_DESCRIPTION);
                process.exit(0);
            })
            .action(handle);

        function handle(options) {
            const profile = profileHelper.runtimeProfile(options.profile);

            if (!options.skillId) {
                chooseSkillProcess(profile, options.debug, (skillId) => {
                    if (!options.force) {
                        cloneStatusCheck.statusCheck(skillId, profile, options.debug, (buildFinished) => {
                            if (buildFinished === undefined) {
                                return;
                            } else if (buildFinished === false) {
                                console.log('[Info]: The skill building is still in progress.\nYou can either wait for the latest version as its in building process, or use "--force" to force to download the skill package regardless of the building status');
                                return;
                            }
                            singleSkillCloneProcess(skillId, profile, options.debug);
                        });
                    } else {
                        if (skillId) {
                            singleSkillCloneProcess(skillId, profile, options.debug);
                        } else {
                            console.error('[Error]: No skill found for the current profile.\n  (use command "ask new" or "ask new --template" to create a new Skill)\n');
                        }
                    }
                });
            } else {
                if (!options.force){
                    cloneStatusCheck.statusCheck(options.skillId, profile, options.debug, (buildFinished) => {
                        if (buildFinished === undefined) {
                            return;
                        } else if (buildFinished === false) {
                            console.log('[Info]: The skill building is still in progress.\nYou can either wait for the latest version as its in building process, or use "--force" to force to download the skill package regardless of the building status');
                            return;
                        }
                        singleSkillCloneProcess(options.skillId, profile, options.debug);
                    });
                } else {
                    singleSkillCloneProcess(options.skillId, profile, options.debug);
                }
            }
        }
    }
};

function singleSkillCloneProcess(skillId, profile, doDebug) {
    cloneSkill.getSkill(skillId, profile, doDebug, (response) => {
        let manifest = response.skillManifest;
        let skillETag = response.eTag;
        let skillInfo = parser.extractSkillInfo(manifest);
        if (!skillInfo) {
            return;
        }
        let projectPath = path.join(process.cwd(), skillInfo.skillName);
        let configPath = path.join(projectPath, '.ask', 'config');
        let skillPath = path.join(projectPath, 'skill.json');
        let modelPath = path.join(projectPath, 'models');
        let lambdaPath = path.join(projectPath, 'lambda');

        console.log('-------------------- Clone Skill Project --------------------');
        cloneProject.clone(projectPath, skillId, skillInfo, profile);
        cloneSkill.clone(skillPath, manifest, skillInfo.skillName, skillETag, configPath, profile);

        // For skills which contains 'custom', clone model first
        if (skillInfo.domainList && skillInfo.domainList.indexOf('custom') !== -1) {
            cloneModel.cloneModel(modelPath, skillId, skillInfo, configPath, profile, doDebug, (error) => {
                if (error) {
                    console.error(error);
                    return;
                }
                if (skillInfo.hasLambdaFunction) {
                    cloneLambda.clone(lambdaPath, skillInfo, configPath, profile, (err, downloadedLambdaMetaDataObjectList) => {
                        if (err) {
                            console.error(err);
                            return;
                        }
                        cloneLocalizing.localizing(skillPath, configPath, downloadedLambdaMetaDataObjectList, profile);
                        getAndCloneISP(skillId, skillInfo.skillName, projectPath, profile, doDebug);
                    });
                } else {
                    getAndCloneISP(skillId, skillInfo.skillName, projectPath, profile, doDebug);
                }
            });
        } else {
            // For skills without 'custom' domain, directly go to lambda clone
            if (skillInfo.hasLambdaFunction) {
                cloneLambda.clone(lambdaPath, skillInfo, configPath, profile, (err, downloadedLambdaMetaDataObjectList) => {
                    if (err) {
                        console.error(err);
                        return;
                    }
                    cloneLocalizing.localizing(skillPath, configPath, downloadedLambdaMetaDataObjectList, profile);
                    getAndCloneISP(skillId, skillInfo.skillName, projectPath, profile, doDebug);
                });    
            } else {
                getAndCloneISP(skillId, skillInfo.skillName, projectPath, profile, doDebug);
            }
        }
    });
}

/**
 * Wrapper of API call to get and clone in-skill products
 * @param skillId the skill id
 * @param skillName the skill name
 * @param projectPath path of the skill project
 * @param profile the user profile
 * @param doDebug the ASK CLI debug mode
 */
function getAndCloneISP(skillId, skillName, projectPath, profile, doDebug) {
    cloneISP.cloneISPFromSkill(skillId, projectPath, profile, doDebug, (error, isEmpty) => {
        if (error) {
            console.error('Failed to clone in-skill product(s):\n' + ispUtil.getFormattedErrorString(error) + '\n');
            return;
        }
        if (isEmpty) {
            console.log("No in-skill product associated with current skill.\n");
            return;
        }
        console.log('In-skill product(s) for ' + skillName + ' cloned to\n' +
            '    .' + path.sep + path.relative(process.cwd(), ispUtil.getISPRootPath(projectPath)) + '\n');
    });
}

function chooseSkillProcess(profile, doDebug, callback) {
    getSkillList(profile, doDebug, (response) => {
        if (!response || !response.skills || response.skills.length < 1) {
            callback();
            return;
        }
        promptProcess(response.skills, (skillId) => {
            callback(skillId);
        });
    });
}

function promptProcess(skillList, callback) {
    if (!skillList || skillList.length < 1) {
        callback();
        return;
    }
    const TITLE_MESSAGE = 'Skill Name  :  Skill Id';
    let sortedList = sortListByLastUpdated(skillList);
    sortedList.splice(0, 0, new inquirer.Separator());
    sortedList.splice(1, 0, new inquirer.Separator(TITLE_MESSAGE));
    sortedList.splice(2, 0, new inquirer.Separator());
    inquirer.prompt([{
        type: 'list',
        message: 'List of all your skills.',
        paginated: true,
        pageSize: LIST_SKILL_PAGE_SIZE,
        name: 'skill',
        choices: sortedList
    }]).then((answers) => {
        let skillId = answers.skill.match(/\[(.+)\]/)[1];
        callback(skillId);
    });
}

function sortListByLastUpdated(skillList) {
    let sortedList = skillList.sort((one, another) => {
        let dateOne = new sugar.Date(one.lastUpdated).raw.getTime();
        let dateAnother = new sugar.Date(another.lastUpdated).raw.getTime();
        return dateAnother - dateOne;
    });
    let result = sortedList.map((element) => {
        let name = findSkillDisplayingName(element.nameByLocale);
        return name + ': [' + element.skillId + ']';
    });
    return result;
}

function findSkillDisplayingName(info) {
    let name;
    if (info.hasOwnProperty('en_US')) {
        name = info.en_US;
    } else if (info.hasOwnProperty('en_GB')) {
        name = info.en_GB;
    } else {
        name = info[Object.keys(info)[0]];
    }
    if (!name || name.length === 0) {
        console.error('Get skill name error. Skill name should not be empty.');
        return;
    }
    return name;
}
