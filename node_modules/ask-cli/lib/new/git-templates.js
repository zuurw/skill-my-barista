'use strict';

const request = require('request');
const git = require('simple-git');
const inquirer = require('inquirer');
const path = require('path');
const jsonfile = require('jsonfile');
const tools = require('../utils/tools');
const installNodeModule = require('../utils/install-node-module');
const jsonUtility = require('../utils/json-utility');
const skillParser = require('../utils/skill-parser');
const displayUtil = require('../utils/display-utility');
const lambdaEndpointUtil = require('../utils/lambda-operation/lambda-endpoint-utility');

module.exports = {
    cloneRepo: cloneRepo
};

function cloneRepo(url, skillName, templateName, profile, callback) {
    getTemplateMap(url, (err, templateMap) => {
        if (err) {
            callback(err);
        } else {
            if (!templateMap) {
                callback('[Error]: Cannot retrieve the template list.');
                process.exit(1);
            }
            getTargetTemplateName(Object.keys(templateMap), templateName, (err, templateName) => {
                if (err) {
                    callback(err);
                } else {
                    const cloneUrl = templateMap[templateName].gitUrl;
                    skillName = skillName || templateName;
                    const validSkillName = preprocessPackageName(skillName);
                    gitCloneTemplate(cloneUrl, validSkillName, profile, callback);
                }
            });
        }
    });
}

// Private
function getTemplateMap(templateUrl, callback) {
    const params = {
        url: templateUrl,
        method: 'GET',
        headers: {
            "User-Agent": 'ask-cli/' + require('../../package.json').version + ' Node/' + process.version
        }
    };
    request(params, (error, response) => {
        if (error || response.statusCode === null) {
            callback('[Error]: Cannot retrieve the template list.', null);
        } else {
            callback(null, tools.convertDataToJsonObject(response.body));
        }
    });
}


function getTargetTemplateName(templateList, inputName, callback) {
    if (inputName) {
        if (templateList.indexOf(inputName) === -1) {
            callback('[Error]: no template associate with the input name', null);
        } else {
            callback(null, inputName);
        }
    } else {
        const templateChoiceQuestion = {
            type: 'list',
            message: 'List of templates you can choose',
            name: 'templateName',
            choices: templateList.sort()
        };
        inquirer.prompt([templateChoiceQuestion]).then((answer) => {
            callback(null, answer.templateName);
        });
    }
}

function gitCloneTemplate(cloneUrl, skillPackageName, profile, callback) {
    const installSpinner = new displayUtil.Spinner(' Initializing Alexa skill project from the chosen template...');
    installSpinner.start();

    const cloneDir = path.join(process.cwd(), skillPackageName);
    git().silent(true).clone(cloneUrl, cloneDir, (err) => {
        if (err) {
            installSpinner.stop();
            callback(err, null);
        } else {
            const skillFilePath = path.join(cloneDir, 'skill.json');
            const manifest = jsonUtility.read(skillFilePath);
            const skillInfo = skillParser.extractSkillInfo(manifest);
            const configPath = path.join(cloneDir, '.ask/config');

            lambdaEndpointUtil.separateLambdaCreateUpdate(skillInfo.skillName, skillInfo.endpointsInfo, skillPackageName, profile, (err, lambdaList) => {
                installSpinner.stop();
                if (err) {
                    callback(err, null);
                } else {
                    installNodeModule.install(lambdaList.createLambdaList, lambdaList.updateLambdaList, cloneDir, (installError) => {
                        changeSkillName(skillPackageName, skillFilePath);
                        adaptToInputProfileName(profile, configPath);
                        changeLambdaName(skillPackageName, profile, configPath);

                        callback(installError, !installError ? skillPackageName : null);
                    });
                }
            });
        }
    });
}

function preprocessPackageName(name) {
    // return a name without space or another weird stuff. so that it can be read.
    return name.toLowerCase().replace(/[\W_]+/g, '-');
}

function changeSkillName(skillName, skillPath) {
    const manifest = jsonfile.readFileSync(skillPath);
    let locales = jsonUtility.getPropertyValueFromObject(manifest, ['manifest', 'publishingInformation', 'locales']);
    if (!locales) {
        locales = jsonUtility.getPropertyValueFromObject(manifest, ['skillManifest', 'publishingInformation', 'locales']);
    }
    Object.keys(locales).forEach(locale => {
        locales[locale].name = skillName;
    });
    jsonfile.writeFileSync(skillPath, manifest, {spaces: 2});
}

function adaptToInputProfileName(profile, configPath) {
    if (profile === 'default') {
        return;
    }
    let config = jsonUtility.read(configPath);
    let defaultConfig = jsonUtility.getPropertyValueFromObject(config, ['deploy_settings', 'default']);
    jsonUtility.writePropertyToJsonOjbect(config, ['deploy_settings', profile], defaultConfig);
    jsonUtility.deletePropertyFromJsonObject(config, ['deploy_settings', 'default']);
    jsonUtility.write(configPath, config);
}

function changeLambdaName(skillName, profile, configPath) {
    let config = jsonfile.readFileSync(configPath);
    let apis = jsonUtility.getPropertyValueFromObject(config, ['deploy_settings', profile, 'merge', 'manifest', 'apis']);
    if (!apis) {
        apis = jsonUtility.getPropertyValueFromObject(config, ['deploy_settings', profile, 'merge', 'skillManifest', 'apis']);
    }
    for (let domain of Object.keys(apis)) {
        for (let key of Object.keys(apis[domain])) {
            if (!apis[domain][key]) {
                continue;
            }
            if (key === 'endpoint') {
                if (apis[domain][key].uri) {
                    apis[domain][key].uri = 'ask-' + domain + '-' + skillName + '-' + profile;
                }
            } else if (key === 'regions') {
                for (let region of Object.keys(apis[domain][key])) {
                    if (apis[domain][key][region].endpoint && apis[domain][key][region].endpoint.uri) {
                        apis[domain][key][region].endpoint.uri = 'ask-' + domain + '-' + skillName + '-' + profile;
                    }
                }
            }
        }
    }
    jsonfile.writeFileSync(configPath, config, {spaces: 2});
}
