'use strict';

const fs = require('fs');
const inquirer = require('inquirer');
const path = require('path');
const mkdirp = require('mkdirp');

const CONSTANTS = require('../utils/constants');
const jsonUtility = require('../utils/json-utility');
const profileHelper = require('../utils/profile-helper');
const template = require('../utils/template');
const gitTemplates = require('./git-templates');
const installNodeModule = require('../utils/install-node-module');
const skillParser = require('../utils/skill-parser');
const displayUtil = require('../utils/display-utility');
const lambdaEndpointUtil = require('../utils/lambda-operation/lambda-endpoint-utility');


// Public
module.exports = {
    createCommand: (commander) => {
        commander
            .command('new')
            .description('create a new skill project on your computer')
            .option('-n, --skill-name <name>', 'create new skill project with skill name')
            .option('-p, --profile <profile>', 'create new skill project under the chosen profile')
            .option('--lambda-name <lambda-name>', 'define lambda name if the skill needs lambda function')
            .option('--template [template-name]', 'generate a skill package locally from the chosen template')
            .option('--url <url>', 'the url to template list, default to Alexa Github repos')
            .option('--debug', 'ask cli debug mode')
            .option('-h, --help', 'output usage information', () => {
                console.log(CONSTANTS.COMMAND.NEW.HELP_DESCRIPTION);
                process.exit(0);
            })
            .action(handle);

        function handle(options) {
            if (typeof options === 'string') {
                console.error('[Error]: Invalid command. Please run "ask new -h" for help.');
                process.exit(1);
            }

            const url = options.url || 'https://s3.amazonaws.com/ask-cli/templates.json';
            const profile = profileHelper.runtimeProfile(options.profile);
            if (options.template) {
                const templateName = (typeof options.template === 'boolean') ? null : options.template;
                gitTemplates.cloneRepo(url, options.skillName, templateName, profile, (err, skillName) => {
                    if (err) {
                        console.error(err);
                        process.exit(1);
                    } else {
                        console.log('Skill "' + skillName + '" has been created based on the chosen template');
                    }
                });
            } else {
                _getSkillName(options.skillName, (skillName) => {
                    let lambdaName;
                    if (options.lambdaName) {
                        if (!skillParser.isValidLambdaFunctionName(options.lambdaName)) {
                            console.warn('Lambda function name is invalid. Pattern of the name should be /[a-zA-Z0-9-_]+/.');
                            process.exit(1);
                        } else {
                            lambdaName = options.lambdaName.trim();
                        }
                    } else {
                        lambdaName = skillName.replace(/ /g, '-').replace(/"/g, '');
                    }
                    _createNewSkillProject(skillName, lambdaName, profile, options.debug);
                });
            }
        }
    }
};


// Private
function _createNewSkillProject(skillName, lambdaName, profile, doDebug) {
    fs.access(process.cwd(), (fs.constants || fs).W_OK, (err) => {
        if (err) {
            console.error('[Error]: No permission to write for the current path.');
            process.exit(1);
        }

        const newProjDir = path.join(process.cwd(), skillName);
        if (fs.existsSync(newProjDir)) {
            console.error('[Error]: Failed to create skill project with the name already existed.');
            process.exit(1);
        }

        const configFilePath = path.join(newProjDir, '.ask', 'config');
        const modelFilePath = path.join(newProjDir, 'models', 'en-US.json');
        const skillFilePath = path.join(newProjDir, 'skill.json');
        
        mkdirp.sync(path.join(newProjDir, '.ask'));
        mkdirp.sync(path.join(newProjDir, 'models'));
        template.copyConfig(configFilePath, '', false, profile);
        template.copyModel(modelFilePath);
        template.copySkill(skillFilePath, skillName);

        const awsProfile = profileHelper.getAWSProfile(profile);
        if (awsProfile && awsProfile.length !== 0) {
            const defaultEndpoint = {
                "endpoint": {
                    "sourceDir": "lambda/custom"
                }
            };
            const addingObjectPath = ['manifest', 'apis', 'custom'];
            jsonUtility.writeToProperty(skillFilePath, addingObjectPath, defaultEndpoint);
            _createNewLambdaCodebase(newProjDir, skillFilePath, lambdaName, profile, doDebug);
        }

        console.log('New project for Alexa skill created.');
    });
}

function _createNewLambdaCodebase(newProjDir, skillFilePath, lambdaName, profile, doDebug) {
    const installSpinner = new displayUtil.Spinner(' Initializing Alexa skill project...');
    installSpinner.start();

    const configFilePath = path.join(newProjDir, '.ask', 'config');
    const customLambdaPath = path.join(newProjDir, 'lambda', 'custom');
    
    mkdirp.sync(path.join(newProjDir, 'lambda', 'custom'));
    template.copyLambda(customLambdaPath);
    template.insertLambda(lambdaName, configFilePath, profile);

    const skillInfo = skillParser.extractSkillInfo(jsonUtility.read(skillFilePath));
    lambdaEndpointUtil.separateLambdaCreateUpdate(skillInfo.skillName, skillInfo.endpointsInfo, newProjDir, profile, (err, lambdaList) => {
        if (err) {
            console.error(err);
            process.exit(1);
        }
        if (lambdaList.createLambdaList.length === 0) {
            console.error('[Error]: Failed to create codebase for Lambda function.');
            process.exit(1);
        }
        installNodeModule.install(lambdaList.createLambdaList, lambdaList.updateLambdaList, newProjDir, doDebug, (err) => {
            installSpinner.stop();
            if (err) {
                console.error(err);
                process.exit(1);
            }
        });
    });
}

function _getSkillName(skillName, callback) {
    if (skillName) {
        callback(skillName.trim());
    } else {
        inquirer.prompt([{
            message: 'Please type in your new skill name: ',
            type: 'input',
            name: 'skillName'
        }]).then((answer) => {
            const skillName = answer.skillName.trim();
            if (skillName.length === 0) {
                console.error('[Error]: Skill name cannot be empty.');
                process.exit(1);
            }
            callback(skillName);
        });
    }
}
