'use strict';

const inquirer = require('inquirer');
const path = require('path');
const fs = require('fs');
const mkdirp = require('mkdirp');

const requestUtil = require('../utils/request-utility');
const displayUtil = require('../utils/display-utility');
const ispUtil = require('../utils/isp-utils/isp-utility.js');
const ispConstants = require('../utils/isp-utils/isp-constants');

module.exports = {
    clone: clone
};

/**
 * Clone in-skill product template file from given URL which directs to the ISP template index file
 * @param indexUrl url to get the index file of in-skill product templates
 * @param name the name assigned to the in-skill product referenceName and file
 * @param callback callback function from the caller
 */
function clone(indexUrl, name, callback) {
    requestUtil.requestPublicUrl(indexUrl, (getISPTemplateIndexError, templateIndexJsonObject) => {
        if (getISPTemplateIndexError || !templateIndexJsonObject) {
            callback(ispConstants.ERROR.CANNOT_RETRIEVE_TEMPLATE_LIST_FROM_S3 + '\n\t' + (getISPTemplateIndexError || ''));
            return;
        }
        getTargetISPTemplateType(templateIndexJsonObject, (getTargetTemplateError, templateUrl, productType, templateName) => {
            if (getTargetTemplateError) {
                callback(getTargetTemplateError);
                return;
            }
            getISPName(templateName, name, (getISPNameError, ispName) => {
                if (getISPNameError) {
                    callback(getISPNameError);
                    return;
                }
                cloneISPTemplateFromUrl(templateUrl, productType, ispName, (cloneTemplateError, ispName, filePath) => {
                    if (cloneTemplateError) {
                        callback(cloneTemplateError);
                        return;
                    }
                    callback(null, ispName, filePath);
                });
            });
        });
    });
}

// Private
/**
 * Get the target ISP template type
 * @param templateIndex JSON object contains the templates index
 * @param callback callback function from the caller
 */
function getTargetISPTemplateType(templateIndex, callback) {
    let productTypeChoiceQuestion = {
        type: 'list',
        message: 'List of in-skill product types you can choose',
        name: 'productType',
        choices: Object.keys(templateIndex).sort()
    };
    /**
     * Prompt user to select product type first
     */
    inquirer.prompt(productTypeChoiceQuestion).then((answer) => {
            let productType = answer.productType;
            let templateMap = templateIndex[productType];

            let templateChoiceQuestion = {
                type: 'list',
                message: 'List of in-skill product templates you can choose',
                name: 'templateName',
                choices: Object.keys(templateMap).sort()
            };
            /**
             * Then prompt user to select from the templates that match selected product type
             */
            inquirer.prompt([templateChoiceQuestion]).then((answer) => {
                    let templateName = answer.templateName;
                    if(!templateMap[templateName]){
                        callback('Selected in-skill product template cannot be found.');
                        return;
                    }
                    let templateUrl = templateMap[templateName].s3Url || templateMap[templateName].url;
                    callback(null, templateUrl, productType, templateName);
                },
                (error) => {
                    callback(error);
                });
        },
        (error) => {
            callback(error);
        });
}

/**
 * Clone the in-skill product template from public url by given information
 * @param cloneUrl url to clone the in-skill product template
 * @param productType in-skill product type
 * @param name the name assigned to the in-skill product referenceName and file
 * @param callback callback function from the caller
 */
function cloneISPTemplateFromUrl(cloneUrl, productType, name, callback) {
    let installSpinner = new displayUtil.Spinner(' Initializing Alexa in-skill product from the chosen template...');
    installSpinner.start();
    requestUtil.requestPublicUrl(cloneUrl, (error, responseBodyJsonObject) => {
        if (error) {
            installSpinner.stop();
            callback(ispConstants.ERROR.CANNOT_RETRIEVE_TEMPLATE + '\n\t' + error);
            return;
        }

        if (!responseBodyJsonObject) {
            installSpinner.stop();
            callback(ispConstants.ERROR.CANNOT_RETRIEVE_TEMPLATE);
            return;
        }

        let ispDefinitionJSON = responseBodyJsonObject;

        //use the passing in name for the file and referenceName
        ispDefinitionJSON.referenceName = name;
        let jsonFileName = ispUtil.getISPFileName(name, null);

        let cloneDirRoot = path.join(process.cwd(), ispConstants.DIRECTORY.ISP_ROOT);
        let cloneDirSub = path.join(cloneDirRoot, productType.toLowerCase());
        let cloneDirLeaf = path.join(cloneDirSub, jsonFileName);

        mkdirp.sync(cloneDirSub);

        /**
         * Log error and quit if the same in-skill product template file already exists
         */
        if (fs.existsSync(cloneDirLeaf)) {
            installSpinner.stop();
            callback('File ' + '.' + path.sep + path.relative(process.cwd(), cloneDirLeaf) + ' already exists, please use other name.');
            return;
        }

        fs.writeFileSync(cloneDirLeaf, JSON.stringify(ispDefinitionJSON, null, 2));
        installSpinner.stop();
        callback(null, name, cloneDirLeaf);
    });
}

/**
 * Get the in-skill product name from user input
 * @param templateName the default template name
 * @param name the name provided by the --isp-name option
 * @param callback
 */
function getISPName(templateName, name, callback) {
    if (name) {
        callback(null, name);
        return;
    }
    inquirer.prompt([{
        message: 'Please type in your new in-skill product name:\n',
        type: 'input',
        name: 'ispName',
        default: templateName
    }]).then((answer) => {
        let ispName = answer.ispName.trim();
        if (!ispUtil.isISPNameValid(ispName)) {
            callback(ispConstants.ERROR.INVALID_ISP_NAME);
            return;
        }
        callback(null, ispName);
    });
}
