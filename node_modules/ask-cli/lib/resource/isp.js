'use strict';

const path = require('path');
const inquirer = require('inquirer');

const profileHelper = require('../utils/profile-helper');
const constants = require('../utils/constants');
const getISPTemplateUtil = require('./get-isp-templates');
const ispUtil = require('../utils/isp-utils/isp-utility');
const ispConstants = require('../utils/isp-utils/isp-constants');
const getISPDeployCollections = require('../deploy/deploy-isp').getISPDeployCollections;
const ispCloneUtil = require('../clone/clone-isp');
const displayUtil = require('../utils/display-utility');

module.exports = {
    buildAddISPCommand: buildAddISPCommand,
    buildRemoveISPCommand: buildRemoveISPCommand,
    showISPStatus: showISPStatus
};

/**
 * Build the "ask add isp" command
 * @param commander commander configuration
 */
function buildAddISPCommand(commander) {
    commander
        .command('isp')
        .usage('[-i|--isp-id <ispId>] [-f|--file <filePath>] [-n|--isp-name <name>] [-p|--profile <profile>] [-h|--help]')
        .description('add an in-skill product to current skill project')
        .option('-f, --file <filePath>', 'add an in-skill product to the current skill project by given file')
        .option('-i, --isp-id <ispId>', 'add an in-skill product to the current skill project by given product ID')
        .option('-n, --isp-name <name>', 'assign a name for the in-skill product')
        .option('-p, --profile <profile>', 'ask cli profile')
        .option('-h, --help', 'output usage information', () => {
            console.log(ispConstants.COMMAND.ADD_ISP.HELP_DESCRIPTION);
            process.exit(0);
        })
        .action(handle);

    function handle(options) {
        if (typeof options === 'string') {
            console.error(ispUtil.getFormattedErrorString('Invalid command. Please run "ask add --help" for help.'));
            return;
        }
        /**
         * Should only perform this commend under the skill product root directory
         */
        if (!ispUtil.isAtSkillRoot()) {
            console.error(ispUtil.getFormattedErrorString(ispConstants.ERROR.NOT_AT_SKILL_PROJECT_ROOT));
            return;
        }

        let profile = profileHelper.runtimeProfile(options.profile);
        let skillProjectPath = process.cwd();
        addISP(skillProjectPath, options, profile);
    }
}

/**
 * Build the "ask remove isp" command
 * @param commander commander configuration
 */
function buildRemoveISPCommand(commander) {
    commander
        .command('isp')
        .usage('[-f|--file <filePath>] [-i|--isp-id <ispId>] [-p|--profile <profile>] [-h|--help]')
        .description('remove an in-skill product from current skill project')
        .option('-f, --file <filePath>', 'remove an in-skill product from the current skill project by given file')
        .option('-i, --isp-id <ispId>', 'remove an in-skill product from current skill project by given ID')
        .option('-p, --profile <profile>', 'ask cli profile')
        .option('-h, --help', 'output usage information', () => {
            console.log(ispConstants.COMMAND.REMOVE_ISP.HELP_DESCRIPTION);
            process.exit(0);
        })
        .action(handle);

    function handle(options) {
        if (typeof options === 'string') {
            console.error(ispUtil.getFormattedErrorString('Invalid command. Please run "ask add --help" for help.'));
            return;
        }
        /**
         * Should only perform this commend under the skill product root directory
         */
        if (!ispUtil.isAtSkillRoot()) {
            console.error(ispUtil.getFormattedErrorString(ispConstants.ERROR.NOT_AT_SKILL_PROJECT_ROOT));
            return;
        }

        let profile = profileHelper.runtimeProfile(options.profile);
        let skillProjectPath = process.cwd();
        removeISP(skillProjectPath, options, profile);
    }
}

/**
 * Show in-skill product's status
 * @param skillProjectPath the root path of skill project
 * @param profile the ASK CLI user profile
 */
function showISPStatus(skillProjectPath, profile) {
    getISPDeployCollections(skillProjectPath, false, profile, (error, deployCollections, ispDefinitionMap) => {
        if (error) {
            console.error('Failed to get the in-skill product status:\n');
            console.error('    ' + ispUtil.getFormattedErrorString(error));
            process.exit(1);
        }
        let ispFileSet = ispUtil.getISPFiles(skillProjectPath, ispUtil.getISPRootPath(skillProjectPath));
        console.log('Profile for the deployment: ' + '[' + profile + ']\n');
        if (deployCollections.error.length > 0) {
            console.warn('Error found in the deploy setting for the following in-skill product(s):');
            console.log('    (Please restore the missing file or modify skill configuration file ' + ispUtil.getConfigPath('') + ' to fix the deploy setting)\n');
            let errorRows = [];
            deployCollections.error.forEach(ispObject => {
                if (ispObject.filePath && ispFileSet.has(ispObject.filePath)) {
                    ispFileSet.delete(ispObject.filePath);
                }
                errorRows.push([ispObject.error, (ispObject.productId), (ispObject.filePath)]);
            });
            displayUtil.printTable(ispConstants.DEPLOY_ERROR_TABLE_HEADERS, errorRows);
            console.log();
        }

        if (deployCollections.update.length !== 0 || deployCollections.create.length !== 0 || deployCollections.associate.length !== 0 || deployCollections.disassociate.length !== 0) {
            let purchasableDeployStatusRows = [];
            let notPurchasableDeployStatusRows = [];
            generateDeployStatusRows(deployCollections, ispDefinitionMap, ispFileSet, purchasableDeployStatusRows, notPurchasableDeployStatusRows);
            if (purchasableDeployStatusRows.length > 0) {
                console.log('Purchasable in-skill product(s) to be deployed:');
                console.log('    (use "ask add isp --file <filePath>/--isp-id <id>" to add in-skill product to current skill)');
                console.log('    (use "ask remove isp --file <filePath>/--isp-id <id>" to remove in-skill product from current skill)\n');
                displayUtil.printTable(ispConstants.DEPLOY_STATUS_TABLE_HEADERS, purchasableDeployStatusRows);
                console.log();
            }
            if (notPurchasableDeployStatusRows.length > 0) {
                console.log('Not purchasable in-skill product(s) to be deployed:');
                console.log('    (use "ask add isp --file <filePath>/--isp-id <id>" to add in-skill product to current skill)');
                console.log('    (use "ask remove isp --file <filePath>/--isp-id <id>" to remove in-skill product from current skill)');
                console.log('    (Change the "purchasableState" to "PURCHASABLE" in the definition file to make the in-skill product purchasable)\n');
                displayUtil.printTable(ispConstants.DEPLOY_STATUS_TABLE_HEADERS, notPurchasableDeployStatusRows);
                console.log();
            }
        } else {
            console.log('No in-skill product to be deployed.\n');
        }

        if (ispFileSet.size > 0) {
            console.log('Untracked in-skill product file(s):');
            console.log('    (use "ask add isp --file <filepath>" to add in-skill product to current skill)\n');
            ispFileSet.forEach(file => {
                console.log('  .' + path.sep + file);
            });
            console.log();
        }
    });
}

//Private
/**
 * Generate deploy status rows
 * @param deployCollections isp deployment collections
 * @param ispInfoMap
 * @param ispFileSet
 * @param purchasableDeployStatusRows
 * @param notPurchasableDeployStatusRows
 */
function generateDeployStatusRows(deployCollections, ispInfoMap, ispFileSet, purchasableDeployStatusRows, notPurchasableDeployStatusRows) {
    if (!deployCollections) {
        return;
    }
    deployCollections.create.forEach(ispToCreate => {
        if (ispInfoMap.get(ispToCreate.filePath)) {
            if (ispInfoMap.get(ispToCreate.filePath).purchasableState === ispConstants.ISP_PURCHASABLE_STATE.PURCHASABLE) {
                purchasableDeployStatusRows.push([ispConstants.DEPLOY_STATUS.ADD, 'N/A', ispToCreate.filePath]);
            } else {
                notPurchasableDeployStatusRows.push([ispConstants.DEPLOY_STATUS.ADD, 'N/A', ispToCreate.filePath]);
            }
        }
        ispFileSet.delete(ispToCreate.filePath);
    });
    deployCollections.associate.forEach(ispToAssociate => {
        if (ispInfoMap.get(ispToAssociate.filePath)) {
            if (ispInfoMap.get(ispToAssociate.filePath).purchasableState === ispConstants.ISP_PURCHASABLE_STATE.PURCHASABLE) {
                purchasableDeployStatusRows.push([ispConstants.DEPLOY_STATUS.ASSOCIATE, ispToAssociate.productId, ispToAssociate.filePath]);
            } else {
                notPurchasableDeployStatusRows.push([ispConstants.DEPLOY_STATUS.ASSOCIATE, ispToAssociate.productId, ispToAssociate.filePath]);
            }
        }
        ispFileSet.delete(ispToAssociate.filePath);
    });
    deployCollections.update.forEach(ispToUpdate => {
        if (ispInfoMap.get(ispToUpdate.filePath)) {
            if (ispInfoMap.get(ispToUpdate.filePath).purchasableState === ispConstants.ISP_PURCHASABLE_STATE.PURCHASABLE) {
                purchasableDeployStatusRows.push([ispConstants.DEPLOY_STATUS.UPDATE, ispToUpdate.productId, ispToUpdate.filePath]);
            } else {
                notPurchasableDeployStatusRows.push([ispConstants.DEPLOY_STATUS.UPDATE, ispToUpdate.productId, ispToUpdate.filePath]);
            }
        }
        ispFileSet.delete(ispToUpdate.filePath);
    });
    deployCollections.disassociate.forEach(ispToDisassociate => {
        if (ispInfoMap.get(ispToDisassociate.filePath)) {
            if (ispInfoMap.get(ispToDisassociate.filePath).purchasableState === ispConstants.ISP_PURCHASABLE_STATE.PURCHASABLE) {
                purchasableDeployStatusRows.push([ispConstants.DEPLOY_STATUS.REMOVE, ispToDisassociate.productId, ispToDisassociate.filePath]);
            } else {
                notPurchasableDeployStatusRows.push([ispConstants.DEPLOY_STATUS.REMOVE, ispToDisassociate.productId, ispToDisassociate.filePath]);
            }
        }
        ispFileSet.delete(ispToDisassociate.filePath);
    });
}

/**
 * Add in-skill product to the local skill project
 * @param skillProjectPath the path of skill project
 * @param options options from the command
 * @param profile ask CLI user profile
 */
function addISP(skillProjectPath, options, profile) {
    if (options.file && options.ispId) {
        console.warn(constants.COMMAND.ADD.HELP_DESCRIPTION);
        return;
    }
    const successMessage = '\nSucceeded to add in-skill product to current skill project:\n' +
        '    (use "ask status --isp" to check what in-skill products will be deployed)\n' +
        '    (use "ask deploy" or "ask deploy --target isp" to deploy in-skill products to your developer account)\n';

    if (options.file) {
        ispUtil.isISPFileValid(options.file, (isISPFileValidError) => {
            if (isISPFileValidError) {
                console.error(ispUtil.getFormattedErrorString(isISPFileValidError));
                return;
            }
            addISPToConfig(skillProjectPath, options.file, null, null, profile, (addISPToConfigError) => {
                if (addISPToConfigError) {
                    console.error(addISPToConfigError);
                    return;
                }
                console.log(successMessage);
            });
        });
    } else if (options.ispId) {
        ispCloneUtil.downloadISPFiles([options.ispId], skillProjectPath, profile, null, (downloadISPError, ispConfigList) => {
            if (downloadISPError) {
                console.error(ispUtil.getFormattedErrorString(downloadISPError));
                return;
            }
            addISPToConfig(skillProjectPath, ispConfigList[0].filePath, ispConfigList[0].productId, ispConfigList[0].eTag, profile, (addISPToConfigError) => {
                if (addISPToConfigError) {
                    console.error(addISPToConfigError);
                    return;
                }
                console.log(successMessage);
            });
        });

    } else {
        if (options.ispName && !ispUtil.isISPNameValid(options.ispName)) {
            console.error(ispUtil.getFormattedErrorString(ispConstants.ERROR.INVALID_ISP_NAME));
            return;
        }
        getISPTemplateUtil.clone(ispConstants.URL.S3_TEMPLATES_ENDPOINT, options.ispName, (ispCloneError, ispName, filePath) => {
            if (ispCloneError) {
                console.error(ispUtil.getFormattedErrorString(ispCloneError));
                return;
            }
            console.log('In-skill product ' + ispName + ' is saved to ' + '.' + path.sep + path.relative(skillProjectPath, filePath));
            addISPToConfig(skillProjectPath, filePath, null, null, profile, (addISPToConfigError) => {
                if (addISPToConfigError) {
                    console.error(addISPToConfigError);
                }
            });
        });
    }
}

/**
 * Add given in-skill product file to the skill project configuration
 * @param skillProjectPath the path of the skill project
 * @param ispFilePath the file path of the in-skill product
 * @param ispId the in-skill product ID
 * @param eTag the ETag
 * @param profile the ask CLI user profile
 * @param callback the callback function to handle the response
 */
function addISPToConfig(skillProjectPath, ispFilePath, ispId, eTag, profile, callback) {
    let newISPConfig = {};
    if (ispId) {
        newISPConfig.productId = ispId;
        newISPConfig.deploy_status = ispConstants.DEPLOY_STATUS.ASSOCIATE;
    } else {
        newISPConfig.deploy_status = ispConstants.DEPLOY_STATUS.ADD;
    }
    if (ispFilePath) {
        newISPConfig.filePath = path.relative(skillProjectPath, ispFilePath);
    }
    if (eTag) {
        newISPConfig.eTag = eTag;
    }

    let ispConfigList = ispUtil.getISPConfigs(skillProjectPath, profile);

    for (let config of ispConfigList) {
        if ((ispId && config.productId === ispId) || (newISPConfig.filePath && config.filePath === newISPConfig.filePath)) {
            if (config.deploy_status === ispConstants.DEPLOY_STATUS.UPDATE) {
                callback('The in-skill product has already been associated with current skill.\n');
                return;
            } else if (config.deploy_status === ispConstants.DEPLOY_STATUS.ADD) {
                callback('The in-skill product has already been added to current skill.\n');
                return;
            } else if (config.deploy_status === ispConstants.DEPLOY_STATUS.REMOVE) {
                config.deploy_status = ispConstants.DEPLOY_STATUS.UPDATE;
                ispUtil.replaceISPConfigs(skillProjectPath, profile, ispConfigList);
                callback('The in-skill product\'s deploy status has already been set to "Remove", now it has been reset.\n');
                return;
            }
        }
    }

    ispConfigList.push(newISPConfig);
    ispUtil.replaceISPConfigs(skillProjectPath, profile, ispConfigList);
    callback();
}

/**
 * Wrap the logic to remove in-skill product from skill project
 * @param skillProjectPath the path of the skill project
 * @param options the command options
 * @param profile the ASK CLI user profile
 */
function removeISP(skillProjectPath, options, profile) {
    if (!(options.file || options.ispId)) {
        console.log('Invalid command, please use one of the following options to remove in-skill product:');
        console.log('    --isp-id <ispId>    remove an in-skill product from skill by given product ID');
        console.log('    --file   <filePath> remove an in-skill product from skill by given file path');
        return;
    }

    if (options.file) {
        ispUtil.isISPFileValid(options.file, (error) => {
            if (error) {
                console.error(ispUtil.getFormattedErrorString(error));
                return;
            }
            removeISPFromSkill(skillProjectPath, options.file, null, profile);
        });
    } else if (options.ispId) {
        removeISPFromSkill(skillProjectPath, null, options.ispId, profile);
    }
}

/**
 * Remove the in-skill product from the local skill project
 * @param skillProjectPath the path of the skill project
 * @param ispFilePath the path of the in-skill product
 * @param ispId the in-skill product ID
 * @param profile the ASK CLI user profile
 */
function removeISPFromSkill(skillProjectPath, ispFilePath, ispId, profile) {
    let ispConfigList = ispUtil.getISPConfigs(skillProjectPath, profile);
    if (ispConfigList.length === 0) {
        console.error('\n' + ispUtil.getFormattedErrorString('The given in-skill product is not found in the current skill project.') + '\n');
        return;
    }

    let ispConfig;
    /**
     * Scan the isp configuration to find the matched entry, quit the loop if it's found
     */
    for (let config of ispConfigList) {
        if ((ispFilePath && config.filePath === path.relative(skillProjectPath, ispFilePath)) ||
            (ispId && config.productId === ispId)) {
            if (config.deploy_status === ispConstants.DEPLOY_STATUS.UPDATE) {
                ispConfig = config;
                break;
            } else if (config.deploy_status === ispConstants.DEPLOY_STATUS.ADD) {
                ispConfig = config;
                ispConfigList.splice(ispConfigList.indexOf(config), 1);
                break;
            } else if (config.deploy_status === ispConstants.DEPLOY_STATUS.ASSOCIATE) {
                ispConfig = config;
                ispConfigList.splice(ispConfigList.indexOf(config), 1);
                break;
            } else if (config.deploy_status === ispConstants.DEPLOY_STATUS.REMOVE) {
                console.error('The given in-skill product\'s deploy status has already been set to "Remove".');
                return;
            }
        }
    }

    if (ispConfig) {
        let message;
        if (ispConfig.deploy_status === ispConstants.DEPLOY_STATUS.UPDATE) {
            message = 'This in-skill product has already been deployed and associated with current skill.';
        } else if (ispConfig.deploy_status === ispConstants.DEPLOY_STATUS.ASSOCIATE) {
            message = 'This in-skill product is being associated with current skill.';
        } else {
            message = 'This in-skill product has already been added to current skill project.';
        }

        let confirmChoiceQuestion = {
            type: 'confirm',
            message: message + '\n  Are you sure to remove it?',
            name: 'confirmChoice',
            default: false
        };
        inquirer.prompt([confirmChoiceQuestion]).then(
            (answerOfConfirmChoiceQuestion) => {
                if (answerOfConfirmChoiceQuestion.confirmChoice) {
                    ispConfig.deploy_status = ispConstants.DEPLOY_STATUS.REMOVE;
                    ispUtil.replaceISPConfigs(skillProjectPath, profile, ispConfigList);
                    console.log('\nSucceeded to remove in-skill product from current skill project:\n' +
                        '    (use "ask status --isp" to view what in-skill products will be deployed)\n' +
                        '    (use "ask add --isp-id / --file" to abort the remove)\n' +
                        '    (use "ask deploy" or "ask deploy --target isp" to deploy changes to your developer account)\n');
                }
            });
    } else {
        console.error('\n' + ispUtil.getFormattedErrorString('The given in-skill product is not found in the current skill project.') + '\n');
    }
}
