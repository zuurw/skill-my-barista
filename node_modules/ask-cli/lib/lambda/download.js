'use strict';

const initAWS = require('../utils/init-aws');
const inquirer = require('inquirer');
const AdmZip = require('adm-zip');
const https = require('https');
const async = require('async');
const sugar = require('sugar');
const path = require('path');
const tmp = require('tmp');
const fs = require('fs');
const profileHelper = require('../utils/profile-helper');
const displayUtil = require('../utils/display-utility');
const lambdaEndpointUtility = require('../utils/lambda-operation/lambda-endpoint-utility')

const LAMBDA_DISPLAY_SIZE = 25;
const LAMBDA_LIST_REQUEST_MAX = 50;

// Public

module.exports = {
    createCommand: createCommand,
    downloadByName: downloadByName,
    lambdaGetFunction: lambdaGetFunction
};

function createCommand(commander) {
    commander
        .command('download')
        .usage('[-f|--function <function>] [-d|--dest <dest>] [-p|--profile <profile>]')
        .description('download an existing Lambda function')
        .option('-f, --function <function>', 'download with function name')
        .option('-d, --dest <dest>', 'set the path of downloaded project')
        .option('-p, --profile <profile>', 'ask cli profile')
        .action(handle);

    function handle(options) {
        const awsProfile = profileHelper.getAWSProfile(profileHelper.runtimeProfile(options.profile));
        if (options.function) {
            const downloadSpinner = new displayUtil.Spinner('Lambda downloading...');
            downloadSpinner.start();
            module.exports.downloadByName(options.function, options.dest, awsProfile, (err, lambdaResult) => {
                downloadSpinner.stop();
                if (err) {
                    console.error(err);
                    process.exit(1);
                }
                console.log(`Lambda function ${lambdaResult.arn} downloaded successfully.`);
            });
        } else {
            downloadByList(awsProfile, (err, selectedFunction) => {
                if (err) {
                    console.error(err);
                    process.exit(1);
                }
                const downloadSpinner = new displayUtil.Spinner('Lambda downloading...');
                downloadSpinner.start();
                module.exports.downloadByName(selectedFunction, options.dest, awsProfile, (err, lambdaResult) => {
                    downloadSpinner.stop();
                    if (err) {
                        console.error(err);
                        process.exit(1);
                    }
                    console.log(`Lambda function ${lambdaResult.arn} downloaded successfully.`);
                });
            });
        }
    }
}

/**
 * Download Lambda function by downloading the code zip file and unzip it to the dest.
 * @param {string} func 
 * @param {string} dest 
 * @param {string} awsProfile 
 * @param {func} callback 
 */
function downloadByName(func, dest, awsProfile, callback) {
    const targetPath = dest || process.cwd();
    if (!fs.existsSync(targetPath)) {
        callback('Please input a valid directory to store the project.', null);
        return;
    }
    const zipFileName = tmp.tmpNameSync({
        prefix: 'asktemp_',
        postfix: '.zip',
        dir: './'
    });
    const zipFilePath = path.join(targetPath, zipFileName);

    downloadFromLambda(func, targetPath, zipFilePath, awsProfile, (err, lambdaData) => {
        callback(err, lambdaData);
    });
}

// Private
function downloadByList(awsProfile, callback) {
    const aws = initAWS.initAWS(awsProfile);
    if (!aws) {
        return;
    }
    getListOfFunctions(aws, (err, lambdaList) => {
        if (err) {
            callback('[Error]: List of functions error.\n' + err, null);
            return;
        }
        inquirer.prompt([{
            type: 'list',
            message: 'Select from your list of lambda functions (Sorted by LastModified)',
            pageSize: LAMBDA_DISPLAY_SIZE,
            name: 'selectedFunction',
            choices: lambdaList
        }]).then((answers) => {
            callback(null, answers.selectedFunction);
        });
    });
}

function downloadFromLambda(func, targetPath, zipFilePath, awsProfile, callback) {
    lambdaGetFunction(func, awsProfile, (err, data) => {
        if (err) {
            callback('[Error]: Get Lambda function error.\n' + err, null);
            return;
        }
        https.get(data.Code.Location, (response) => {
            unzipLambda(response, targetPath, zipFilePath, () => {
                // console.log('    ' + func + ' download finished.\n');
                const result = {
                    arn: func,
                    revisionId: data.Configuration.RevisionId
                };
                callback(null, result);
            });
        });
    });
}

/**
 * Call getFunction from Lambda client and callback with the response data.
 * @param {string} func 
 * @param {string} awsProfile 
 * @param {func} callback 
 */
function lambdaGetFunction(func, awsProfile, callback) {
    const aws = initAWS.initAWS(awsProfile);
    if (!aws) {
        callback('[Error]: Failed to initialize AWS client for current profile.', null);
        return;
    }
    const lambdaParseInfo = lambdaEndpointUtility.parseLambdaArn(func);
    const lambdaClient = lambdaParseInfo ? new aws.Lambda({region: lambdaParseInfo.awsRegion}) : new aws.Lambda();
    const params = {
        FunctionName: func
    };

    lambdaClient.getFunction(params, (err, data) => {
        callback(err, data);
    });
}

function unzipLambda(response, targetPath, zipFilePath, callback) {
    if (!fs.existsSync(targetPath)) {
        fs.mkdirSync(targetPath);
    }
    let zipWriteStream = fs.createWriteStream(zipFilePath);
    let stream = response.pipe(zipWriteStream);
    stream.on('close', () => {
        let zip = new AdmZip(zipFilePath);
        zip.extractAllTo(targetPath, true);
        fs.unlinkSync(zipFilePath);
        callback();
    });
}

function getListOfFunctions(aws, callback) {
    let pageMarker = '';
    let dataStore = [];
    let lambdaClient = new aws.Lambda();
    let param = {
        MaxItems: LAMBDA_LIST_REQUEST_MAX
    };

    async.doWhilst(
        (loopCallback) => {
            lambdaClient.listFunctions(param, (err, data) => {
                if (err) {
                    loopCallback(err, null);
                    return;
                }
                dataStore = dataStore.concat(defineListFormat(data));
                pageMarker = data.NextMarker;
                loopCallback(null, dataStore);
            });
        },
        () => {
            param.Marker = pageMarker;
            return pageMarker !== null;
        },
        (err, data) => {
            callback(err, sortListByLastModified(data));
        }
    );
}

function defineListFormat(data) {
    let functionNameArray = data.Functions.map((func) => {
        return {
            FunctionName: func.FunctionName,
            LastModified: func.LastModified
        };
    });
    return functionNameArray;
}

function sortListByLastModified(list) {
    let sortedList = list.sort((one, another) => {
        let dateOne = new sugar.Date(one.LastModified).raw.getTime();
        let dateAnother = new sugar.Date(another.LastModified).raw.getTime();
        return dateAnother - dateOne;
    });
    let result = sortedList.map((element) => {
        return element.FunctionName;
    });
    return result;
}
