'use strict';

const fs = require('fs');
const path = require('path');
const jsdiff = require('diff');
const async = require('async');

const CONSTANTS = require('../utils/constants');
const tools = require('../utils/tools');
const apiWrapper = require('../api/api-wrapper');
const ifMatchUtil = require('../utils/if-match-utility');


module.exports = {
    diff: diff
};

/**
 * Main function for diff-model.
 * This function will callback with diffResult in the data structure as:
 * {
 *   "locale": {
 *     "existIn": enum within CONSTANTS.DIFF.RESOURCE_EXIST_IN
 *     "isLatest": true or false (when false, the diff field won't exist),
 *     "localPath": the local file path (the expected file name for it),
 *     "remoteContent": {
 *       schema,
 *       eTag
 *     }
 *     "diff": the jsdiff result between local and remote
 *   }
 * }
 * @param {string} skillId 
 * @param {boolean} doDebug 
 * @param {string} profile 
 * @param {Function} callback 
 */
function diff(skillId, doDebug, profile, callback) {
    // 1.Get local ETag mapping (from resource setting in project config file)
    const localETagMap = ifMatchUtil.getModelETag(profile);
    // 2.Get remote ETag mapping (by get-skill-status request)
    getRemoteETagMap(skillId, doDebug, profile, (err, remoteETagMap) => {
        if (err) {
            callback(err, null);
            return;
        }
        // 3.Compare local and remote model ETags to decide "existIn", "isLatest" and "diff" field
        compareLocalAndRemoteModel(skillId, localETagMap, remoteETagMap, doDebug, profile, (err, diffResult) => {
            if (err) {
                callback(err);
                return;
            }

            callback(null, diffResult);
        });
    });
}

function getRemoteETagMap(skillId, doDebug, profile, callback) {
    apiWrapper.callGetSkillStatus(skillId, [CONSTANTS.SKILL.RESOURCES.INTERACTION_MODEL], profile, doDebug, (data) => {
        if (data.statusCode === 404) {
            callback(CONSTANTS.DIFF.ERROR_MESSAGE.MODEL_STATUS_NOT_EXIST, null);
            return;
        }
        const buildResponse = tools.convertDataToJsonObject(data.body);
        if (!buildResponse.hasOwnProperty(CONSTANTS.SKILL.RESOURCES.INTERACTION_MODEL)) {
            callback(CONSTANTS.DIFF.ERROR_MESSAGE.MODEL_STATUS_NOT_EXIST, null);
            return;
        }
        const modelStatus = buildResponse[CONSTANTS.SKILL.RESOURCES.INTERACTION_MODEL];
        validateModelStatusResponse(modelStatus, (err) => {
            if (err) {
                callback(err, null);
                return;
            }
            
            callback(null, getRemoteETagMapFromModelBuildResponse(modelStatus));
        });
    });
}

function validateModelStatusResponse(modelStatus, callback) {
    let isValid = true;
    for (let locale of Object.keys(modelStatus)) {
        if (!modelStatus[locale].hasOwnProperty('eTag') || 
            !modelStatus[locale].hasOwnProperty('lastUpdateRequest') || 
            !modelStatus[locale].lastUpdateRequest.hasOwnProperty('status')) {
            
            isValid = false;
            callback(CONSTANTS.DIFF.ERROR_MESSAGE.MODEL_STATUS_PARSE_FAILED);
            break;
        } else if (modelStatus[locale].lastUpdateRequest.status === CONSTANTS.SKILL.BUILD_STATUS.IN_PROGRESS) {
            isValid = false;
            callback(CONSTANTS.DIFF.ERROR_MESSAGE.MODEL_STATUS_IN_PROGRESS);
            break;
        }
    }
    if (isValid) {
        callback();
    }
}

function getRemoteETagMapFromModelBuildResponse(modelStatus) {
    const remoteETagMap = {};
    Object.keys(modelStatus).forEach((modelLocale) => {
        remoteETagMap[modelLocale] = {};
        remoteETagMap[modelLocale].eTag = modelStatus[modelLocale].eTag;
    });
    return remoteETagMap;
}

function compareLocalAndRemoteModel(skillId, localETagMap, remoteETagMap, doDebug, profile, callback) {
    const diffResult = {};
    
    // 1.Decide the "existIn" field
    if (localETagMap) {
        Object.keys(localETagMap).forEach((locale) => {
            diffResult[locale] = {};
            diffResult[locale].existIn = CONSTANTS.DIFF.RESOURCE_EXIST_IN.LOCAL;
        });
    }

    if (remoteETagMap) {
        async.eachSeries(Object.keys(remoteETagMap), (locale, getModelCallback) => {
            setTimeout(() => {
                if (!diffResult.hasOwnProperty(locale)) {
                    diffResult[locale] = {};
                }
                if (diffResult[locale].existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.LOCAL) {
                    diffResult[locale].existIn = CONSTANTS.DIFF.RESOURCE_EXIST_IN.BOTH;
                } else {
                    diffResult[locale].existIn = CONSTANTS.DIFF.RESOURCE_EXIST_IN.REMOTE;
                }

                // 2.Validate with the existence of localPath and set "localPath" field
                const localFilePath = `models${path.sep}${locale}.json`;
                const isLocalFileExisting = fs.existsSync(path.join(process.cwd(), localFilePath));
                if (diffResult[locale].existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.LOCAL || 
                    diffResult[locale].existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.BOTH) {
                    if (!isLocalFileExisting) {
                        getModelCallback(CONSTANTS.DIFF.ERROR_MESSAGE.CONFLICT_SETTING_CONFIG_NO_FILE(localFilePath));
                        return;
                    }
                } else if (diffResult[locale].existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.REMOTE) {
                    if (isLocalFileExisting) {
                        getModelCallback(CONSTANTS.DIFF.ERROR_MESSAGE.CONFLICT_SETTING_FILE_NO_CONFIG(localFilePath));
                        return;
                    }
                }
                diffResult[locale].localPath = localFilePath;

                // 3.Set "remoteContent" field for BOTH and REMOTE
                if (diffResult[locale].existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.REMOTE ||
                    diffResult[locale].existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.BOTH) {
                    getRemoteModel(skillId, locale, doDebug, profile, (err, modelData) => {
                        if (err) {
                            getModelCallback(err);
                            return;
                        }
                        diffResult[locale].remoteContent = modelData;

                        // 4.Set "isLatest" field and "diff" field for BOTH
                        if (diffResult[locale].existIn !== CONSTANTS.DIFF.RESOURCE_EXIST_IN.BOTH) {
                            getModelCallback();
                            return;
                        }
                        diffResult[locale].isLatest = localETagMap[locale].eTag === remoteETagMap[locale].eTag;
                        diffResult[locale].diff = diffLocalAndRemoteModel(diffResult[locale].localPath, modelData.schema, locale);
                        getModelCallback();
                    });
                }
            }, CONSTANTS.CONFIGURATION.TIME_INTERVAL_FOR_ASYNC_REQUEST);
        }, (err) => {
            callback(err, err ? null : diffResult);
        });
    }
}

function getRemoteModel(skillId, locale, doDebug, profile, callback) {
    apiWrapper.callGetModel(skillId, CONSTANTS.SKILL.STAGE.DEVELOPMENT, locale, profile, doDebug, (data) => {
        const remoteModel = tools.convertDataToJsonObject(data.body);
        if (!remoteModel) {
            callback(CONSTANTS.DIFF.ERROR_MESSAGE.MODEL_GET_FAILED, null);
            return;
        }
        callback(null, {
            schema: remoteModel,
            eTag: data.headers.etag
        });
    });
}

function diffLocalAndRemoteModel(localPath, remoteModel, locale) {
    const modelFilePath = path.join(process.cwd(), localPath);
    const localModelFile = fs.existsSync(modelFilePath) ? fs.readFileSync(modelFilePath, 'utf8') : '';
    const modelFileName = locale + '.json';
    const remoteModelStr = JSON.stringify(remoteModel, null, 2);
    return jsdiff.createTwoFilesPatch(
        CONSTANTS.DIFF.DIFF_DISPLAY.MODEL_OLD_NAME_PREFIX + modelFileName, 
        CONSTANTS.DIFF.DIFF_DISPLAY.MODEL_NEW_NAME_PREFIX + modelFileName, 
        localModelFile, remoteModelStr, 
        CONSTANTS.DIFF.DIFF_DISPLAY.OLD_HEADER, CONSTANTS.DIFF.DIFF_DISPLAY.NEW_HEADER, 
        { context: CONSTANTS.DIFF.DIFF_DISPLAY.CONTEXT_NUMBER });
}
