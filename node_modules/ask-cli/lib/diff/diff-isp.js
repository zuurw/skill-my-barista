'use strict';

const fs = require('fs');
const async = require('async');
const jsonfile = require('jsonfile');
const jsdiff = require('diff');

const cloneIspUtil = require('../clone/clone-isp');
const constants = require('../utils/constants');
const ispConstants = require('../utils/isp-utils/isp-constants');
const deployIspUtil = require('../deploy/deploy-isp');

module.exports = {
    diff: diff
};

/**
 * Function for diff-ISP
 * This function callbacks with a Map contains objects with the data structure as:
 * {
 *  key: "ispId",
 *  value: {
 *    "isLatest": true or false,
 *    "filePath": path to the in-skill product definition JSON file
 *    "diff": the jsdiff result between local and remote
 *  }
 * @param skillId skill Id
 * @param skillProjectPath path to the skill project
 * @param doDebug ASK CLI debug mode
 * @param profile ASK CLI user profile
 * @param callback callback with response
 */
function diff(skillId, skillProjectPath, doDebug, profile, callback) {
    if (!skillId) {
        callback('Missing skill ID.');
        return;
    }
    if (!skillProjectPath || !fs.existsSync(skillProjectPath)) {
        callback('Invalid skill project path.');
        return;
    }
    if (!profile) {
        callback(ispConstants.ERROR.MISSING_USER_PROFILE);
        return;
    }
    deployIspUtil.getISPDeployCollections(skillProjectPath, false, profile, (deployCollectionsError, deployCollections) => {
        if (deployCollectionsError) {
            callback(deployCollectionsError);
            return;
        }
        if (deployCollections.disassociate.length === 0 &&
            deployCollections.update.length === 0 &&
            deployCollections.create.length === 0 &&
            deployCollections.associate.length === 0) {
            callback(null);
            return;
        }
        let ispConfigList = [];
        if (deployCollections.update.length > 0) {
            ispConfigList = ispConfigList.concat(deployCollections.update);
        }
        if (deployCollections.associate.length > 0) {
            ispConfigList = ispConfigList.concat(deployCollections.associate);
        }
        if (deployCollections.disassociate.length > 0) {
            ispConfigList = ispConfigList.concat(deployCollections.disassociate);
        }

        diffLocalAndRemoteISP(skillId, ispConfigList, doDebug, profile, (diffError, diffResultsMap) => {
            if (diffError) {
                callback(diffError);
                return;
            }
            callback(null, diffResultsMap);
        });
    });

}

function diffLocalAndRemoteISP(skillId, ispConfigList, doDebug, profile, callback) {
    let diffResultsMap = new Map();
    if (!ispConfigList || ispConfigList.length === 0) {
        callback(null);
        return;
    }
    getLocalISPMap(ispConfigList, (getLocalISPMapError, localISPInfoMap) => {
        if (getLocalISPMapError) {
            callback(getLocalISPMapError);
            return;
        }
        if (!localISPInfoMap || localISPInfoMap.size === 0) {
            callback(null, diffResultsMap);
            return;
        }

        //TODO move the getISPs from cloneISPUtil to isp resource module
        cloneIspUtil.getISPFromSkill(skillId, ispConstants.ISP_STAGE.DEVELOPMENT, profile, doDebug, (getIspError, remoteISPInfoMap) => {
            if (getIspError) {
                callback(getIspError);
                return;
            }
            diffResultsMap = generateISPDiffResultMap(localISPInfoMap, remoteISPInfoMap);
            callback(null, diffResultsMap);
        });
    });

}

function generateISPDiffResultMap(localISPInfoMap, remoteISPInfoMap) {
    const diffResultsMap = new Map();
    if (localISPInfoMap && localISPInfoMap.size > 0) {
        localISPInfoMap.forEach((locaISPInfo, localProductId) => {
            diffResultsMap.set(
                localProductId,
                {
                    existIn: constants.DIFF.RESOURCE_EXIST_IN.LOCAL,
                    filePath: locaISPInfo.filePath
                });
        });
    }
    if (remoteISPInfoMap && remoteISPInfoMap.size > 0) {
        remoteISPInfoMap.forEach((remoteISPInfo, remoteProductId) => {
            if (diffResultsMap.has(remoteProductId)) {
                const diffResult = diffResultsMap.get(remoteProductId);
                diffResult.existIn = constants.DIFF.RESOURCE_EXIST_IN.BOTH;
                const localISPInfo = localISPInfoMap.get(remoteProductId);
                if (!remoteISPInfo.eTag || localISPInfo.eTag === remoteISPInfo.eTag) {
                    diffResult.isLatest = true;
                } else {
                    diffResult.isLatest = false;
                }
                if (!isJsonDeepEqual(localISPInfo.definition, remoteISPInfo.definition)) {
                    diffResult.diff = jsdiff.createTwoFilesPatch(
                        constants.DIFF.DIFF_DISPLAY.ISP_OLD_NAME_PREFIX + localISPInfo.filePath,
                        constants.DIFF.DIFF_DISPLAY.ISP_NEW_NAME_PREFIX + localISPInfo.filePath,
                        JSON.stringify(localISPInfo.definition, null, 2),
                        JSON.stringify(remoteISPInfo.definition, null, 2),
                        constants.DIFF.DIFF_DISPLAY.OLD_HEADER,
                        constants.DIFF.DIFF_DISPLAY.NEW_HEADER,
                        {context: constants.DIFF.DIFF_DISPLAY.CONTEXT_NUMBER}
                    );
                }

            } else {
                diffResultsMap.set(remoteProductId, {existIn: constants.DIFF.RESOURCE_EXIST_IN.REMOTE});
            }
        });
    }
    return diffResultsMap;
}

function isJsonDeepEqual(localJson, remoteJson) {
    const jsonDiffList = jsdiff.diffJson(localJson, remoteJson);
    if (!jsonDiffList || jsonDiffList.length === 0) {
        return true;
    }
    return jsonDiffList.every(changeObject => {
        if (changeObject.added || changeObject.removed) {
            return false;
        }
        return true;
    });
}

function getLocalISPMap(ispConfigList, callback) {
    const localISPMap = new Map();
    if (!ispConfigList || ispConfigList.length === 0) {
        callback();
        return;
    }
    async.each(
        ispConfigList,
        (ispConfig, loopCallback) => {
            if (ispConfig.filePath && fs.existsSync(ispConfig.filePath)) {
                jsonfile.readFile(ispConfig.filePath, (readFileError, ispDefinition) => {
                    if (readFileError) {
                        loopCallback(readFileError);
                        return;
                    }
                    ispConfig.definition = ispDefinition;
                    localISPMap.set(ispConfig.productId, ispConfig);
                    loopCallback();
                });
            }
        },
        (error) => {
            if (error) {
                callback('Failed to get in-skill product(s) from local project.');
                return;
            }
            callback(null, localISPMap);
        });
}
