'use strict';

const path = require('path');
const fs = require('fs');

const profileHelper = require('../utils/profile-helper');
const jsonUtility = require('../utils/json-utility');
const displayUtility = require('../utils/display-utility');
const diffSkill = require('./diff-skill');
const diffModel = require('./diff-model');
const diffLambda = require('./diff-lambda');
const diffISP = require('./diff-isp').diff;
const CONSTANTS = require('../utils/constants');
const ispUtil = require('../utils/isp-utils/isp-utility');
const diffUtils = require('./diff-utils');

module.exports = {
    createCommand: (commander) => {
        commander
            .command('diff')
            .description('compare the local skill resource(s) with the latest version from remote')
            .option('-t, --target <target>', 'select diff target from "skill", "model", "lambda", "isp" or "all"')
            .option('--debug', 'ask cli debug mode')
            .option('-p, --profile <profile>', 'ask cli profile')
            .option('-h, --help', 'output usage information', () => {
                console.log(CONSTANTS.COMMAND.DIFF.HELP_DESCRIPTION);
                process.exit(0);
            })
            .action(handle);

        function handle(options) {
            const profile = profileHelper.runtimeProfile(options.profile);
            const doDebug = options.debug;

            let target = options.target;
            if (target) {
                target = target.toLowerCase();
            }
            if (target && ['all', 'skill', 'model', 'lambda', 'isp'].indexOf(target) === -1) {
                console.error(CONSTANTS.DIFF.ERROR_MESSAGE.TARGET_NOT_VALID);
                process.exit(1);
            }

            if (!fs.existsSync(path.join(process.cwd(), '.ask', 'config'))) {
                console.error(CONSTANTS.DIFF.ERROR_MESSAGE.CWD_INVALID);
                process.exit(1);
            }
            const askConfig = jsonUtility.read(path.join(process.cwd(), '.ask', 'config'));
            const skillId = jsonUtility.getPropertyValueFromObject(askConfig, ['deploy_settings', profile, 'skill_id']);
            if (!skillId) {
                console.error(CONSTANTS.DIFF.ERROR_MESSAGE.SKILL_ID_NOT_FOUND);
                process.exit(1);
            }

            if (!jsonUtility.getPropertyValueFromObject(askConfig, ['deploy_settings', profile, 'resources'])) {
                console.error(CONSTANTS.DIFF.ERROR_MESSAGE.RESOURCE_NOT_EXISTS);
                process.exit(1);
            }

            if (target === 'skill') {
                diffSkillAndPrint(skillId, doDebug, profile, (err, diffResult) => {
                    if (err) {
                        handleErrorMessage(err);
                    }
                    printAggregatedDiffResult(diffResult, null);
                });
            } else if (target === 'model') {
                diffModelAndPrint(skillId, doDebug, profile, (err, diffResult) => {
                    if (err) {
                        handleErrorMessage(err);
                    }
                    printAggregatedDiffResult(null, diffResult);
                });
            } else if (target === 'lambda') {
                diffLambdaAndPrint(skillId, doDebug, profile, (err) => {
                    if (err) {
                        handleErrorMessage(err);
                    }
                });
            } else if (target === 'isp') {
                diffISPAndPrint(skillId, process.cwd(), doDebug, profile, (ispDiffError, ispDiffResultsMap) => {
                    if (ispDiffError) {
                        handleErrorMessage(ispDiffError);
                    }
                    printAggregatedDiffResult(null, null, ispDiffResultsMap);
                });
            } else if (!target || target === 'all') {
                diffSkillAndPrint(skillId, doDebug, profile, (diffSkillError, skillDiffResult) => {
                    if (diffSkillError) {
                        handleErrorMessage(diffSkillError);
                    }
                    diffModelAndPrint(skillId, doDebug, profile, (diffModelError, modelDiffResult) => {
                        if (diffModelError) {
                            handleErrorMessage(diffModelError);
                        }
                        diffLambdaAndPrint(skillId, doDebug, profile, (diffLambdaError) => {
                            if (diffLambdaError) {
                                handleErrorMessage(diffLambdaError);
                            }
                            diffISPAndPrint(skillId, process.cwd(), doDebug, profile, (diffIspError, ispDiffResultsMap) => {
                                if (diffIspError) {
                                    handleErrorMessage(diffIspError);
                                }
                                printAggregatedDiffResult(skillDiffResult, modelDiffResult, ispDiffResultsMap);
                            });
                        });
                    });
                });
            }
        }
    }
};

function handleErrorMessage(errMessage) {
    console.error(errMessage);
    console.log();
    if (!diffUtils.isErrorMessageSkippable(errMessage)) {
        process.exit(1);
    }
}

function diffSkillAndPrint(skillId, doDebug, profile, callback) {
    const skillSpinner = new displayUtility.Spinner(` Retrieving remote skill resource and calculating the diff...`);
    skillSpinner.start();
    diffSkill.diff(skillId, doDebug, profile, (err, diffResult) => {
        skillSpinner.stop();
        if (err) {
            callback(err, null);
            return;
        }

        printSkillDiff(diffResult);
        callback(null, diffResult);
    });
}

function printSkillDiff(skillDiffResult) {
    if (!skillDiffResult || Object.keys(skillDiffResult).length === 0) {
        console.log(`No skill resource for the current skill.\n`);
        return;
    }
    resolveDiffResultAndPrint(skillDiffResult, 'skill.json');
    console.log();
}

function diffModelAndPrint(skillId, doDebug, profile, callback) {
    const modelSpinner = new displayUtility.Spinner(` Retrieving remote model resource(s) and calculating the diff...`);
    modelSpinner.start();
    diffModel.diff(skillId, doDebug, profile, (err, diffResult) => {
        modelSpinner.stop();
        if (err) {
            callback(err, null);
            return;
        }

        printModelDiff(diffResult);
        callback(null, diffResult);
    });
}

function printModelDiff(modelDiffResult) {
    if (!modelDiffResult || Object.keys(modelDiffResult).length === 0) {
        console.log(`No model resource for the current skill.\n`);
        return;
    }
    Object.keys(modelDiffResult).forEach((modelLocale) => {
        resolveDiffResultAndPrint(modelDiffResult[modelLocale], `models${path.sep}${modelLocale}.json`);
    });
    console.log();
}

function diffLambdaAndPrint(skillId, doDebug, profile, callback) {
    const lambdaSpinner = new displayUtility.Spinner(` Retrieving remote lambda resource(s) and calculating the diff...`);
    lambdaSpinner.start();
    diffLambda.diff(skillId, doDebug, profile, (err, diffResult) => {
        lambdaSpinner.stop();
        if (err) {
            callback(err, null);
            return;
        }
        
        printLambdaDiff(diffResult);
        callback(null, diffResult);
    });
}

function printLambdaDiff(lambdaDiffResult) {
    if (!lambdaDiffResult || Object.keys(lambdaDiffResult).length === 0) {
        console.log(`No lambda resource for the current skill.\n`);
        return;
    }
    Object.keys(lambdaDiffResult).forEach((lambdaArn) => {
        resolveDiffResultAndPrint(lambdaDiffResult[lambdaArn], `Lambda function ${lambdaArn}`);
    });
    console.log();
}

function diffISPAndPrint(skillId, skillProjectPath, doDebug, profile, callback) {
    const ispDiffSpinner = new displayUtility.Spinner(` Retrieving remote in-skill product(s) and calculating the diff...`);
    ispDiffSpinner.start();
    diffISP(skillId, skillProjectPath, doDebug, profile, (diffISPError, ispDiffResultsMap) => {
        ispDiffSpinner.stop();
        if (diffISPError) {
            callback(ispUtil.getFormattedErrorString(diffISPError), null);
            return;
        }
        if (!ispDiffResultsMap || ispDiffResultsMap.size === 0) {
            console.log('No in-skill product for the current skill.\n');
            callback(null, ispDiffResultsMap);
            return;
        }
        printISPDiff(ispDiffResultsMap);
        callback(null, ispDiffResultsMap);
    });
}

function printISPDiff(ispDiffResultsMap) {
    if (!ispDiffResultsMap || Object.prototype.toString.call(ispDiffResultsMap) !== '[object Map]') {
        return;
    }
    ispDiffResultsMap.forEach((diffResult, ispProductId) => {
        resolveDiffResultAndPrint(diffResult, diffResult.filePath ? diffResult.filePath : ispProductId);
    });
    console.log();
}

function printAggregatedDiffResult(skillDiff, modelDiff, ispDiffResultsMap) {
    let aggregatedResult = `=========================== DIFF RESULT ===========================\n`;
    let willDisplayStr = false;

    if (skillDiff && skillDiff.diff) {
        willDisplayStr = true;
        aggregatedResult += (skillDiff.diff + '\n');
    }

    if (modelDiff) {
        Object.keys(modelDiff).forEach((modelLocale) => {
            if (modelDiff[modelLocale].diff) {
                willDisplayStr = true;
                aggregatedResult += (modelDiff[modelLocale].diff + '\n');
            }
        });
    }

    // No diff result need to displayed for Lambda

    if (ispDiffResultsMap && Object.prototype.toString.call(ispDiffResultsMap) === '[object Map]' && ispDiffResultsMap.size > 0) {
        ispDiffResultsMap.forEach(ispDiffResult => {
            if (ispDiffResult.diff) {
                willDisplayStr = true;
                aggregatedResult += (ispDiffResult.diff + '\n');
            }
        });
    }

    if (willDisplayStr) {
        console.log(aggregatedResult);
    }
}

function resolveDiffResultAndPrint(diffResult, fileName) {
    if (diffResult.existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.BOTH) {
        if (!diffResult.isLatest) {
            console.log(`Your ${fileName} differs from the latest version.`);
        } else {
            console.log(`Your ${fileName} is up to date.`);
        }
    } else if (diffResult.existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.REMOTE) {
        console.log(`The ${fileName} file exists in the latest remote version of your skill, but is missing from your local skill project.`);
    }
}
