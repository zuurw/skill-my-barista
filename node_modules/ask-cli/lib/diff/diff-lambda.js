'use strict';

const async = require('async');
const path = require('path');
const fs = require('fs');
const jsonfile = require('jsonfile');

const ifMatchUtil = require('../utils/if-match-utility');
const skillParser = require('../utils/skill-parser');
const profileHelper = require('../utils/profile-helper');
const tools = require('../utils/tools');
const apiWrapper = require('../api/api-wrapper');
const download = require('../lambda/download');
const lambdaEndpointUtility = require('../utils/lambda-operation/lambda-endpoint-utility');
const CONSTANTS = require('../utils/constants');

module.exports = {
    diff: diff
};

/**
 * Main function for diff-lambda.
 * This function will callback with diffResult in the data structure as:
 * {
 *   "lambda ARN": {
*      "existIn": enum within CONSTANTS.DIFF.RESOURCE_EXIST_IN
 *     "isLatest": true or false (when false, the diff field won't exist),
 *     "localPath": the local file path (the expected file name for it),
 *   }
 * }
 * @param {string} skillId 
 * @param {boolean} doDebug 
 * @param {string} profile 
 * @param {Function} callback 
 */
function diff(skillId, doDebug, profile, callback) {
    // 1.Get the revisionId mapping for local lambda (from resource setting in project config file)
    const localRevisionIdMap = ifMatchUtil.getLambdaRevisionId(profile);
    // 2.Get the revisionId mapping for the remote lambda (by getFunction request)
    getRemoteLambdaRevisionIdMap(skillId, doDebug, profile, (getRemoteMapError, remoteRevisionIdMap) => {
        if (getRemoteMapError) {
            callback(getRemoteMapError, null);
            return;
        }
        // 3.Compare local and remote revisionId mapping and return the diffResult
        compareLocalAndRemoteLambda(localRevisionIdMap, remoteRevisionIdMap, profile, (compareLocalRemoteError, diffResult) => {
            if (compareLocalRemoteError) {
                callback(compareLocalRemoteError, null);
                return;
            }
            callback(null, diffResult);
        });
    });
}

function getRemoteLambdaRevisionIdMap(skillId, doDebug, profile, callback) {
    const revisionIdMap = {};
    getLambdaSetFromSkillManifest(skillId, doDebug, profile, (getLambdaSetError, arnSet) => {
        if (getLambdaSetError) {
            callback(getLambdaSetError, null);
            return;
        }
        const awsProfile = profileHelper.getAWSProfile(profile);
        async.each(arnSet, (arn, downloadCallBack) => {
            download.lambdaGetFunction(arn, awsProfile, (getLambdaError, data) => {
                if (getLambdaError) {
                    downloadCallBack(`${CONSTANTS.DIFF.ERROR_MESSAGE.LAMBDA_GET_FAILED} ${getLambdaError}`);
                } else {
                    revisionIdMap[arn] = data.Configuration.RevisionId;
                    downloadCallBack();
                }
            });
        }, (error) => {
            callback(error, error ? null : revisionIdMap);
        });
    });
}

function getLambdaSetFromSkillManifest(skillId, doDebug, profile, callback) {
    apiWrapper.callGetSkill(skillId, CONSTANTS.SKILL.STAGE.DEVELOPMENT, profile, doDebug, (data) => {
        if (data.statusCode === 303) {
            // Either IN_PROGRESS or FAILED will result in 303 for get-skill. 
            // Since the skill is verified not IN_PROGRESS before, we can only ask developers to force deploy when FAILED happens.
            callback(CONSTANTS.DIFF.ERROR_MESSAGE.SKILL_STATUS_FAILED, null);
        } else {
            const remoteManifest = tools.convertDataToJsonObject(data.body);
            callback(null, skillParser.getLambdaArnSetFromSkill(remoteManifest));
        }
    });
}

function compareLocalAndRemoteLambda(localRevisionIdMap, remoteRevisionIdMap, profile, callback) {
    const diffResult = {};

    // 1.Decide the "existIn" field
    if (localRevisionIdMap) {
        Object.keys(localRevisionIdMap).forEach((arn) => {
            diffResult[arn] = {};
            diffResult[arn].existIn = CONSTANTS.DIFF.RESOURCE_EXIST_IN.LOCAL;
        });
    }
    if (remoteRevisionIdMap) {
        Object.keys(remoteRevisionIdMap).forEach((arn) => {
            if (!diffResult.hasOwnProperty(arn)) {
                diffResult[arn] = {};
            }
            if (diffResult[arn].existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.LOCAL) {
                diffResult[arn].existIn = CONSTANTS.DIFF.RESOURCE_EXIST_IN.BOTH;
            } else {
                diffResult[arn].existIn = CONSTANTS.DIFF.RESOURCE_EXIST_IN.REMOTE;
            }

            // 2.Validate with the existence of localPath and set "localPath" field
            const sourceDirFromArn = getSourceDirFromLambdaArn(arn, profile);
            const localFilePath = sourceDirFromArn ? `${sourceDirFromArn}${path.sep}` : `lambda${path.sep}${lambdaEndpointUtility.getLambdaFolderName(arn)}${path.sep}`;
            const isLocalFileExisting = fs.existsSync(path.join(process.cwd(), localFilePath));
            if (diffResult[arn].existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.LOCAL || 
                diffResult[arn].existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.BOTH) {
                if (!isLocalFileExisting) {
                    callback(CONSTANTS.DIFF.ERROR_MESSAGE.CONFLICT_SETTING_CONFIG_NO_FILE(localFilePath), null);
                    return;
                }
            } else if (diffResult[arn].existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.REMOTE) {
                if (isLocalFileExisting) {
                    callback(CONSTANTS.DIFF.ERROR_MESSAGE.CONFLICT_SETTING_FILE_NO_CONFIG(localFilePath), null);
                    return;
                }
            }
            diffResult[arn].localPath = localFilePath;

            // 3.Set "isLatest" field
            if (diffResult[arn].existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.BOTH) {
                diffResult[arn].isLatest = remoteRevisionIdMap[arn] === localRevisionIdMap[arn];
            }
        });
    }
    
    callback(null, diffResult);
}

function getSourceDirFromLambdaArn(arn, profile) {
    let manifest, configContent;
    try {
        manifest = jsonfile.readFileSync(path.join(process.cwd(), 'skill.json'));
        configContent = jsonfile.readFileSync(path.join(process.cwd(), '.ask', 'config'));
    } catch (err) {
        return null;
    }
    if (!manifest || !configContent) {
        return null;
    }

    return skillParser.getSourceDirByLambdaArn(manifest, configContent, arn, profile);
}
