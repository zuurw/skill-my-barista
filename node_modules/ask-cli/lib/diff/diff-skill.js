'use strict';

const path = require('path');
const jsdiff = require('diff');
const fs = require('fs');

const CONSTANTS = require('../utils/constants');
const tools = require('../utils/tools');
const jsonUtility = require('../utils/json-utility');
const apiWrapper = require('../api/api-wrapper');
const ifMatchUtil = require('../utils/if-match-utility');
const skillSchemaProcessor = require('../deploy/skill-schema-pocessor');


module.exports = {
    diff: diff
};

/**
 * Main function for diff-skill.
 * This function will callback with diffResult in the data structure as:
 * {
 *   "existIn": enum within CONSTANTS.DIFF.RESOURCE_EXIST_IN
 *   "isLatest": true or false (when false, the diff field won't exist),
 *   "localPath": the local file path (the expected file name for it),
 *   "remoteContent": {
 *     schema,
 *     eTag
 *   }
 *   "diff": the jsdiff result between local and remote
 * }
 * @param {string} skillId 
 * @param {boolean} doDebug 
 * @param {string} profile 
 * @param {Function} callback (err, diffResult)
 */
function diff(skillId, doDebug, profile, callback) {
    const diffResult = {};

    // 1.Get local (resource setting in project config file) ETag
    const localETag = ifMatchUtil.getSkillETag(profile);
    if (typeof localETag === 'string' && localETag.trim()) {
        diffResult.existIn = CONSTANTS.DIFF.RESOURCE_EXIST_IN.LOCAL;
    }
    // 2.Get remote (get-skill-status request) ETag
    getRemoteETag(skillId, doDebug, profile, (err, remoteETag) => {
        if (err) {
            callback(err, null);
            return;
        }
        // 3.Decide the "existIn" field
        if (typeof remoteETag === 'string' && remoteETag.trim()) {
            diffResult.existIn = diffResult.existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.LOCAL ?
                                                        CONSTANTS.DIFF.RESOURCE_EXIST_IN.BOTH :
                                                        CONSTANTS.DIFF.RESOURCE_EXIST_IN.REMOTE;
        }

        // 4.Validate with the existence of localPath and set "localPath" field
        const localFilePath = 'skill.json';
        const isLocalFileExisting = fs.existsSync(path.join(process.cwd(), localFilePath));
        if (diffResult.existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.LOCAL || 
            diffResult.existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.BOTH) {
            if (!isLocalFileExisting) {
                callback(CONSTANTS.DIFF.ERROR_MESSAGE.CONFLICT_SETTING_CONFIG_NO_FILE(localFilePath), null);
                return;
            }
        } else if (diffResult.existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.REMOTE) {
            if (isLocalFileExisting) {
                callback(CONSTANTS.DIFF.ERROR_MESSAGE.CONFLICT_SETTING_FILE_NO_CONFIG(localFilePath), null);
                return;
            }
        }
        diffResult.localPath = localFilePath;

        // 5.Set "remoteContent" field for BOTH and REMOTE
        if (diffResult.existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.REMOTE ||
            diffResult.existIn === CONSTANTS.DIFF.RESOURCE_EXIST_IN.BOTH) {
            getRemoteSkill(skillId, doDebug, profile, (err, manifestData) => {
                if (err) {
                    callback(err, null);
                    return;
                }
                diffResult.remoteContent = manifestData;

                // 6.Decide "isLatest" field and "diff" field for BOTH
                if (diffResult.existIn !== CONSTANTS.DIFF.RESOURCE_EXIST_IN.BOTH) {
                    callback(null, diffResult);
                    return;
                }
                diffResult.isLatest = localETag === remoteETag;
                diffLocalAndRemoteSkill(diffResult.localPath, diffResult.remoteContent.schema, profile, (err, diff) => {
                    if (err) {
                        callback(err, null);
                        return;
                    }
                    diffResult.diff = diff;
                    callback(null, diffResult);
                });
            });
        }
    });
}

function getRemoteETag(skillId, doDebug, profile, callback) {
    apiWrapper.callGetSkillStatus(skillId, [CONSTANTS.SKILL.RESOURCES.MANIFEST], profile, doDebug, (data) => {
        if (data.statusCode === 404)  {
            callback(CONSTANTS.DIFF.ERROR_MESSAGE.SKILL_STATUS_NOT_EXISTS, null);
            return;
        }
        const buildResponse = tools.convertDataToJsonObject(data.body);
        if (!buildResponse.hasOwnProperty(CONSTANTS.SKILL.RESOURCES.MANIFEST)) {
            callback(CONSTANTS.DIFF.ERROR_MESSAGE.SKILL_STATUS_NOT_EXISTS, null);
            return;
        }
        if (isSkillBuildInProgress(buildResponse)) {
            callback(CONSTANTS.DIFF.ERROR_MESSAGE.SKILL_STATUS_IN_PROGRESS, null);
            return;
        }
        const remoteETag = jsonUtility.getPropertyValueFromObject(buildResponse,
            [CONSTANTS.SKILL.RESOURCES.MANIFEST, 'eTag']);
        callback(null, remoteETag || '');
    });
}

function isSkillBuildInProgress(buildResponse) {
    const skillStatus = jsonUtility.getPropertyValueFromObject(buildResponse, 
        [CONSTANTS.SKILL.RESOURCES.MANIFEST, 'lastUpdateRequest', 'status']);
    return skillStatus === CONSTANTS.SKILL.BUILD_STATUS.IN_PROGRESS;
}

function getRemoteSkill(skillId, doDebug, profile, callback) {
    apiWrapper.callGetSkill(skillId, CONSTANTS.SKILL.STAGE.DEVELOPMENT, profile, doDebug, (data) => {
        if (data.statusCode === 303) {
            // Either IN_PROGRESS or FAILED will result in 303 for get-skill. 
            // Since the skill is verified not IN_PROGRESS before, we can only ask developers to force deploy when FAILED happens.
            callback(CONSTANTS.DIFF.ERROR_MESSAGE.SKILL_STATUS_FAILED, null);
        } else {
            const remoteManifest = tools.convertDataToJsonObject(data.body);
            callback(null, {
                schema: remoteManifest,
                eTag: data.headers.etag
            });
        }
    });
}

function diffLocalAndRemoteSkill(localPath, remoteManifest, profile, callback) {
    const projectConfigFilePath = path.join(process.cwd(), '.ask', 'config');
    const skillFilePath = path.join(process.cwd(), localPath);
    skillSchemaProcessor.parseSkill(projectConfigFilePath, skillFilePath, profile, (mergedManifest) => {
        const remoteManifestStr = JSON.stringify(remoteManifest, null, 2);
        const localManifestStr = JSON.stringify(mergedManifest, null, 2);
        callback(null, jsdiff.createTwoFilesPatch(
            CONSTANTS.DIFF.DIFF_DISPLAY.SKILL_OLD_NAME, CONSTANTS.DIFF.DIFF_DISPLAY.SKILL_NEW_NAME,
            localManifestStr, remoteManifestStr, 
            CONSTANTS.DIFF.DIFF_DISPLAY.OLD_HEADER, CONSTANTS.DIFF.DIFF_DISPLAY.NEW_HEADER,
            { context: CONSTANTS.DIFF.DIFF_DISPLAY.CONTEXT_NUMBER }));
    });
}
