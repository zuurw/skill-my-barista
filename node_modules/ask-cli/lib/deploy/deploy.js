'use strict';

const path = require('path');
const fs = require('fs');
const profileHelper = require('../utils/profile-helper');
const skillSchemaProcessor = require('./skill-schema-pocessor');
const deployEnablement = require('./deploy-enablement');
const deployLocalizing = require('./deploy-localizing');
const deploySkill = require('./deploy-skill');
const deployISP = require('./deploy-isp');
const deployModel = require('./deploy-model');
const deployLambda = require('./deploy-lambda');
const CONSTANTS = require('../utils/constants');
const tools = require('../utils/tools');

// Public
module.exports = {
    createCommand: (commander) => {
        commander
            .command('deploy')
            .description('deploy a skill to your developer account')
            .option('--no-wait', 'asynchronous deployment for interaction model', {isDefault: true})
            .option('-t, --target <target>', 'deploy "lambda", "model", "skill", "isp" or "all"')
            .option('--force', 'deploy the local project regardless of eTag')
            .option('-p, --profile <profile>', 'ask cli profile')
            .option('--debug', 'ask cli debug mode')
            .option('-f, --force', 'force the deployment by ignoring eTags and revisionId')
            .option('-h, --help', 'output usage information', () => {
                console.log(CONSTANTS.COMMAND.DEPLOY.HELP_DESCRIPTION);
                process.exit(0);
            })
            .action(handle);

        function handle(options) {
            let currentDir = process.cwd();
            let target = options.target;
            let isWaiting = options.wait;
            let profile = profileHelper.runtimeProfile(options.profile);

            if (isWaiting === undefined) {
                isWaiting = true;
            }
            if (target) {
                target = target.toLowerCase();
            }
            if (target && ['all', 'lambda', 'skill', 'model', 'isp'].indexOf(target) === -1) {
                console.error('[Error]: Target not recognized. Options can only be "all", "lambda", "skill", "isp" and "model".');
                return;
            }
            let skillFile = path.join(currentDir, 'skill.json');
            if (!fs.existsSync(skillFile)) {
                console.error("[Error]: Can't find skill.json in current working directory.");
                return;
            }
            tools.v1ManifestTransformer(skillFile, false, profile);
            // TODO config should not be the throttling for deploy. We should think about creating config when config not existed.
            let projectConfigFile = path.join(currentDir, '.ask', 'config');
            if (!fs.existsSync(projectConfigFile)) {
                console.error('[Error]: Failed to deploy. Please ensure current working directory is the root of your skill project.');
                return;
            }

            skillSchemaProcessor.parseSkill(projectConfigFile, skillFile, profile, (preprocessedSkillSchema, skillInfo, skillId) => {
                if (target === 'lambda') {
                    deployLambda.deployLambda(skillId, skillInfo, options.force, profile, options.debug, (generatedLambdaList) => {
                        deployLocalizing.localizingCreatedLambdaARN(generatedLambdaList, projectConfigFile, profile);
                    });
                } else if (target === 'skill') {
                    deploySkill.deploySkill(skillId, preprocessedSkillSchema, skillInfo, options.force, profile, options.debug, () => {
                    });
                } else if (target === 'model') {
                    if (skillInfo.domainList.indexOf('custom') === -1) {
                        console.error('[Error]: No model need to be deployed.');
                        return;
                    }
                    deployModel.deployModel(skillId, skillInfo, isWaiting, options.force, profile, options.debug);
                } else if (target === 'isp') {
                    console.log('Profile for the deployment: ' + '[' + profile + ']');
                    deployISP.deployISP(skillId, currentDir, options.force, profile, options.debug, () => {
                    });
                } else if (!target || target === 'all') {
                    deploySkill.deploySkill(skillId, preprocessedSkillSchema, skillInfo, options.force, profile, options.debug, (skillIdFromDeploySkill) => {
                        deployModel.deployModel(skillIdFromDeploySkill, skillInfo, isWaiting, options.force, profile, options.debug, () => {
                            deployLambda.deployLambda(skillIdFromDeploySkill, skillInfo, options.force, profile, options.debug, (generatedLambdaList) => {
                                if (generatedLambdaList && generatedLambdaList.length !== 0) {
                                    deployLocalizing.localizingCreatedLambdaARN(generatedLambdaList, projectConfigFile, profile);
                                    const updatedSkillSchema = skillSchemaProcessor.updateSkillSchemaWithLambdaCreation(generatedLambdaList, preprocessedSkillSchema);
                                    deploySkill.updateSkillPostLambdaCreation(skillIdFromDeploySkill, updatedSkillSchema, options.force, profile, options.debug, () => {
                                        deployISP.deployISP(skillIdFromDeploySkill, currentDir, options.force, profile, options.debug, (deployISPError) => {
                                            if (deployISPError) {
                                                return;
                                            }
                                            // TODO: Correct it to isWaiting OR model exists, because model may not exist when skillId is not blank
                                            // Enable skill if developer isWaiting OR skill has been created before (skillId is not blank)
                                            if (isWaiting || (typeof skillId === 'string' && skillId.trim().length !== 0)) {
                                                deployEnablement.enable(skillIdFromDeploySkill, profile, options.debug, (error) => {
                                                    if (error) {
                                                        console.error(error);
                                                    } else {
                                                        console.log('Your skill is now deployed and enabled in the development stage.\n' +
                                                            'Try invoking the skill by saying “Alexa, open {your_skill_invocation_name}” or simulate an invocation via the `ask simulate` command.'
                                                        );
                                                        process.exit(0);
                                                    }
                                                });
                                            }
                                        });
                                    });
                                } else {
                                    deployISP.deployISP(skillIdFromDeploySkill, currentDir, options.force, profile, options.debug, (deployISPError) => {
                                        if (deployISPError) {
                                            return;
                                        }
                                        // Enable skill if developer isWaiting OR skill has been created before (skillId is not blank)
                                        if (isWaiting || (typeof skillId === 'string' && skillId.trim().length !== 0)) {
                                            deployEnablement.enable(skillIdFromDeploySkill, profile, options.debug, (error) => {
                                                if (error) {
                                                    console.error(error);
                                                } else {
                                                    console.log('Your skill is now deployed and enabled in the development stage.\n' +
                                                        'Try invoking the skill by saying “Alexa, open {your_skill_invocation_name}” or simulate an invocation via the `ask simulate` command.'
                                                    );
                                                    process.exit(0);
                                                }
                                            });
                                        }
                                    });
                                }
                            });
                        });
                    });
                }
            });
        }
    }
};
