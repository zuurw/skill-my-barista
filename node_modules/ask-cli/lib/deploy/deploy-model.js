'use strict';

const apiWrapper = require('../api/api-wrapper');
const tools = require('../utils/tools');
const jsonUtility = require('../utils/json-utility');
const displayUtil = require('../utils/display-utility');
const CONSTANTS = require('../utils/constants');
const async = require('async');
const path = require('path');
const fs = require('fs');
const retry = require('retry');
const ifMatchUtil = require('../utils/if-match-utility');


// Public
module.exports.deployModel = (skillId, skillInfo, isWaiting, forceDeployment, profile, doDebug, callback) => {
    if (!skillId) {
        console.error('[Error]: Cannot find skill ID to deploy the model to.');
        process.exit(1);
    }
    const isModelIncluded = skillInfo.domainList.indexOf('custom') !== -1;
    if (!isModelIncluded) {
        callback();
        return;
    }

    const localeList = getModelListFromProject(skillInfo.publishLocaleList);
    if (!localeList || localeList.length === 0) {
        console.log('No model need to be deployed.');
        if (callback && typeof callback === 'function') {
            callback();
        }
        return;
    }

    checkBuildStatus(skillId, localeList, profile, doDebug, (modelStatusMap) => {
        const eTagObject = forceDeployment ? null : ifMatchUtil.getModelETag(profile);

        if (isAnyModelBuildInProgress(modelStatusMap)) {
            console.log('Model build in progress. Please try again when previous build finishes.');
            process.exit();
        }

        updateModel(skillId, localeList, eTagObject, profile, doDebug, () => {
            if (isWaiting) {
                pollingModelStatus(skillId, localeList, profile, doDebug, (error, modelStatus) => {
                    if (error) {
                        console.error(error);
                        process.exit(1);
                    } else {
                        // modelStatus has two keys: failureArray and successList
                        if (modelStatus.failureArray.length !== 0) {
                            ifMatchUtil.recordModelEtag(modelStatus.successList, profile);
                            printOutModelBuildingStatus(modelStatus.failureArray, 'Failure');
                            console.error('Deployment process stops due to model building failure.');
                        } else {
                            ifMatchUtil.recordModelEtag(modelStatus.successList, profile);
                            console.log('Model deployment finished.');
                            if (typeof callback === 'function' && callback) {
                                callback();
                            }
                        }
                    }
                });
            } else {
                console.log('\nModel submitted. Please use the following command to track the model build status:' +
                            '\n    ask api get-skill-status -s ' + skillId + '\n');

                if (typeof callback === 'function' && callback) {
                    callback();
                }
            }
        });
    });
};


/**
 * Get model list from skill project.
 * Model list should be subset of skillInfo.publishLocaleList
 *
 * @params skillInfo.publishLocaleList
 * @return true list of models to be deployed
 */
function getModelListFromProject(publishLocaleList) {
    const modelFolderPath = path.join(process.cwd(), 'models');
    if (!fs.existsSync(modelFolderPath)) {
        return false;
    }
    const localeList = fs.readdirSync(modelFolderPath).map((file) => {
        return path.basename(file, '.json');
    });
    return localeList.filter((locale) => {
        return publishLocaleList.indexOf(locale) !== -1;
    });
}

function updateModel(skillId, localeList, eTagObject, profile, doDebug, callback) {
    async.eachSeries(localeList, (locale, deployModelCallback) => {
        setTimeout(() => {
            const eTag = eTagObject && eTagObject[locale] ? eTagObject[locale].eTag : null;
            highLevelUpdateModel(skillId, locale, eTag, profile, doDebug, (response) => {
                // if it's eTag mismatch, server will response with 412 precondition failed
                if (response.statusCode === 412) {
                    deployModelCallback(CONSTANTS.IF_MATCH.ERROR.MISMATCH('model'));
                } else {
                    deployModelCallback();
                }
            });
        }, CONSTANTS.CONFIGURATION.TIME_INTERVAL_FOR_ASYNC_REQUEST);
    }, (error) => {
        if (error) {
            console.log(error);
            process.exit(1);
        }
        callback();
    });
}

function checkBuildStatus(skillId, localeList, profile, doDebug, callback) {
    const modelStatusMap = {};
    const checkBuildStatusSpinner = displayUtil.Spinner(' Checking model status...');
    checkBuildStatusSpinner.start();

    apiWrapper.callGetSkillStatus(skillId, [CONSTANTS.SKILL.RESOURCES.INTERACTION_MODEL], profile, doDebug, (data) => {
        checkBuildStatusSpinner.stop();
        if (data.statusCode === 404) {
            callback(null);
            return;
        }
        const buildResponse = tools.convertDataToJsonObject(data.body);
        localeList.forEach((locale) => {
            const skillStatusPathToStatus = [CONSTANTS.SKILL.RESOURCES.INTERACTION_MODEL, locale, 'lastUpdateRequest', 'status'];
            const localeStatus = jsonUtility.getPropertyValueFromObject(buildResponse, skillStatusPathToStatus);
            if (localeStatus) {
                modelStatusMap[locale] = localeStatus;
            }
        });

        callback(modelStatusMap);
    });
}

/**
 * Check if any model build status is IN_PROGRESS from the modelStatusMap by locale.
 * @param {Object} modelStatusMap 
 */
function isAnyModelBuildInProgress(modelStatusMap) {
    if (!modelStatusMap) {
        return false;
    }
    for (let locale of Object.keys(modelStatusMap)) {
        if (modelStatusMap[locale] === CONSTANTS.SKILL.BUILD_STATUS.IN_PROGRESS) {
            return true;
        }
    }
    return false;
}

function highLevelUpdateModel(skillId, locale, eTag, profile, doDebug, callback) {
    const modelFile = path.join(process.cwd(), 'models', locale + '.json');
    if (!fs.existsSync(modelFile)) {
        console.log("Can't find " + locale + '.json in ./models');
        return;
    }
    const modelSchema = jsonUtility.read(modelFile);
    apiWrapper.callUpdateModel(skillId, CONSTANTS.SKILL.STAGE.DEVELOPMENT, locale, modelSchema, eTag, profile, doDebug, callback);
}

/**
 * Entry function for polling status for model building.
 * Will call keepPollingModelBuildStatus to continuously poll.
 * 
 * @param skillId 
 * @param localeList 
 * @param profile 
 * @param doDebug 
 * @param callback failureArray and successList
 */
function pollingModelStatus(skillId, localeList, profile, doDebug, callback) {
    const pollingStatusSpinner = displayUtil.Spinner(' Polling the status for all models...');
    pollingStatusSpinner.start();

    keepPollingModelBuildStatus(skillId, localeList, profile, doDebug, (err, modelStatus) => {
        pollingStatusSpinner.stop();
        callback(err, modelStatus);
    });
}

/**
 * Polling for model build status every 5 seconds and return with an array of build failed locales
 * 
 * @param skillId 
 * @param localeList 
 * @param profile 
 * @param doDebug 
 * @param callback result of (err, modelStatus)
 */
function keepPollingModelBuildStatus(skillId, localeList, profile, doDebug, callback) {
    // The maximum waiting time, which is the last time's polling will be:
    //   Math.min(minTimeout * Math.pow(1.25, 30), maxTimeout) ~= 1h
    // which is a good estimate for model status polling
    const operation = retry.operation({
        retries: CONSTANTS.CONFIGURATION.RETRY.GET_MODEL_STATUS.MAX_RETRY,
        minTimeout: CONSTANTS.CONFIGURATION.RETRY.GET_MODEL_STATUS.MIN_TIME_OUT,
        factor: CONSTANTS.CONFIGURATION.RETRY.GET_MODEL_STATUS.FACTOR
    });

    const modelStatus = {};
    modelStatus.failureArray = [];
    modelStatus.successList = [];

    let isRetryFinished = false;
    operation.attempt(() => {
        apiWrapper.callGetSkillStatus(skillId, [CONSTANTS.SKILL.RESOURCES.INTERACTION_MODEL], profile, doDebug, (data) => {
            if (operation.retry(isRetryFinished ? null : 'needRetry')) {
                if (data.statusCode !== 404) {
                    let buildResponse = tools.convertDataToJsonObject(data.body);
                    localeList.forEach((locale) => {
                        const skillStatusPathToStatus = ['interactionModel', locale, 'lastUpdateRequest', 'status'];
                        const localeStatus = jsonUtility.getPropertyValueFromObject(buildResponse, skillStatusPathToStatus);
                        if (localeStatus === null) {
                            callback('[Error]: Invalid response for interactionModel status from get-skill-status request.');
                            isRetryFinished = true;
                            return;
                        }
                        if (localeStatus === CONSTANTS.SKILL.BUILD_STATUS.FAILURE) {
                            modelStatus.failureArray.push(locale);
                        } else if (localeStatus === CONSTANTS.SKILL.BUILD_STATUS.SUCCESS) {
                            localeList.splice(localeList.indexOf(locale), 1);
                            modelStatus.successList.push({
                                locale: locale,
                                eTag: buildResponse.interactionModel[locale].eTag
                            });
                        } else if (localeStatus !== CONSTANTS.SKILL.BUILD_STATUS.IN_PROGRESS) {
                            callback('[Error]: Invalid response for interactionModel status from get-skill-status request.');
                            isRetryFinished = true;
                        }
                    });

                    if (localeList.length === 0) {
                        callback(null, modelStatus);
                        isRetryFinished = true;
                    }
                }
            }

            if (operation.attempts() === CONSTANTS.CONFIGURATION.RETRY.GET_MANIFEST_STATUS.MAX_RETRY) {
                callback('[Error]: Polling timeout. The interaction model is still in building progress.');
                isRetryFinished = true;
            }
        });
    });
}

function printOutModelBuildingStatus(modelLocaleList, status) {
    for (let locale of modelLocaleList) {
        console.log('[' + status + '] ' + locale);
    }
}
