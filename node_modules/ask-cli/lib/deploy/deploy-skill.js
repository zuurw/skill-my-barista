'use strict';

const parser = require('../utils/skill-parser');
const jsonUtility = require('../utils/json-utility');
const apiWrapper = require('../api/api-wrapper');
const tools = require('../utils/tools');
const domainRegistry = require('../utils/domain-registry');
const skillParser = require('../utils/skill-parser');
const displayUtil = require('../utils/display-utility');
const CONSTANTS = require('../utils/constants');
const jsonfile = require('jsonfile');
const inquirer = require('inquirer');
const retry = require('retry');
const path = require('path');
const profileHelper = require('../utils/profile-helper');
const ispUtil = require('../utils/isp-utils/isp-utility');
const ifMatchUtil = require('../utils/if-match-utility');

module.exports = {
    deploySkill: deploySkill,
    updateSkillPostLambdaCreation: updateSkillPostLambdaCreation,
    pollingSkillStatus: pollingSkillStatus
};

function deploySkill(skillId, preprocessedSkillSchema, skillInfo, forceDeployment, profile, doDebug, callback) {
    let submitReadySkillSchema = deleteInvalidEndpoint(preprocessedSkillSchema);
    if (!skillId || (typeof skillId === 'string' && !skillId.trim())) {
        let skillName = skillInfo.skillName;
        if (!skillName || !skillName.length) {
            console.warn('Skill name should not be empty. Please set skill name in skill.json.');
            return;
        }
        if (!parser.isSkillNameValid(skillName)) {
            console.warn('Skill name is not valid. ' +
                         'Pattern of the name should be /[a-zA-Z0-9-_]+/.');
            return;
        }
        console.log('-------------------- Create Skill Project --------------------');
        console.log('Profile for the deployment: [' + profile + ']');
        const createSkillSpinner = displayUtil.Spinner(' Creating new skill...');
        createSkillSpinner.start();
        createSkill(submitReadySkillSchema, profile, doDebug, (skillId) => {
            updateSkillConfig(skillId, profile);
            pollingSkillStatus(skillId, profile, doDebug, (response) => {
                createSkillSpinner.stop();
                handleSkillStatus(response, skillId, profile, callback);
            });
        });
    } else {
        checkClone(skillInfo, profile, () => {
            console.log('-------------------- Update Skill Project --------------------');
            const updateSkillSpinner = new displayUtil.Spinner(' Updating skill...');
            updateSkillSpinner.start();
            checkSkillStatus(skillId, profile, doDebug, () => {

                let skillETag = forceDeployment ? null : ifMatchUtil.getSkillETag(profile);
                apiWrapper.callUpdateSkill(skillId, CONSTANTS.SKILL.STAGE.DEVELOPMENT, submitReadySkillSchema, skillETag, profile, doDebug, (response) => {
                    // if it's eTag mismatch, server will response with 412 precondition failed
                    if (response.statusCode === 412) {
                        updateSkillSpinner.stop();
                        console.error(CONSTANTS.IF_MATCH.ERROR.MISMATCH('skill'));
                        process.exit(1);
                    }
                    pollingSkillStatus(skillId, profile, doDebug, (response) => {
                        updateSkillSpinner.stop();
                        handleSkillStatus(response, skillId, profile, callback);
                    });
                });
            });
        });
    }
}

function updateSkillPostLambdaCreation(skillId, manifest, force, profile, doDebug, callback) {
    const updateSkillSpinner = new displayUtil.Spinner(' Updating skill with the Lambda function just created...');
    updateSkillSpinner.start();

    const newEtag = force ? null : ifMatchUtil.getSkillETag(profile);
    // ask deploy will only call update-skill with development stage
    apiWrapper.callUpdateSkill(skillId, CONSTANTS.SKILL.STAGE.DEVELOPMENT, manifest, newEtag, profile, doDebug, (response) => {
        if (response.statusCode === 412) {
            updateSkillSpinner.stop();
            console.error(CONSTANTS.IF_MATCH.ERROR.MISMATCH('skill'));
            process.exit(1);
        }
        pollingSkillStatus(skillId, profile, doDebug, (response) => {
            updateSkillSpinner.stop();
            if (response.status === CONSTANTS.SKILL.BUILD_STATUS.SUCCESS) {
                ifMatchUtil.recordSkillEtag(response.eTag, profile);
                if (typeof callback === 'function' && callback) {
                    callback();
                }
            }
        });
    });
}

// Private
function createSkill(manifest, profile, doDebug, callback) {
    let vendorId = profileHelper.resolveVendorId(profile);
    if (!vendorId) {
        console.error('[Error]: cannot find vendor id associated with the current profile');
        return;
    }

    apiWrapper.callCreateSkill(manifest, vendorId, profile, doDebug, (data) => {
        let skillData = tools.convertDataToJsonObject(data.body);
        if (skillData) {
            callback(skillData.skillId);
        }
    });
}

function updateSkillConfig(skillId, profile) {
    let projectConfigFile = path.join(process.cwd(), '.ask', 'config');
    let projectConfig = jsonUtility.read(projectConfigFile);
    projectConfig.deploy_settings[profile].skill_id = skillId;
    jsonfile.writeFileSync(projectConfigFile, projectConfig, {spaces: 2});
}

function checkClone(skillInfo, profile, callback) {
    let projectConfigPath = path.join(process.cwd(), '.ask', 'config');
    let projectConfig = jsonUtility.read(projectConfigPath);
    let isCloned = jsonUtility.getPropertyValueFromObject(projectConfig, ['deploy_settings', profile, 'was_cloned']);
    if (!isCloned) {
        callback();
    } else {
        console.log('This skill project was cloned from a pre-existing skill. Deploying this project will');
        console.log('  - Update skill metadata (skill.json)');

        if (skillInfo.domainList.indexOf('custom') !== -1) {
            console.log('  - Update interaction model (models/*.json)');
        }

        if (Object.keys(skillInfo.endpointsInfo).length > 0) {
            console.log('  - Deploy the Lambda function(s) in ./lambda/*');
        }

        if(ispUtil.getISPConfigs(process.cwd(), profile).length > 0){
            console.log('  - Deploy the in-skill product(s) in ./isps/*');
        }

        let confirm = {
            type: 'confirm',
            name: 'isAllowed',
            message: 'Do you want to proceed with the above deployments?'
        };
        inquirer.prompt(confirm).then((answers) => {
            if (answers.isAllowed) {
                projectConfig.deploy_settings[profile].was_cloned = false;
                jsonfile.writeFileSync(projectConfigPath, projectConfig, {spaces: 2});
                console.log();
                callback();
            }
        });
    }
}

function checkSkillStatus(skillId, profile, doDebug, callback) {
    let checkSkillStatusSpinner = displayUtil.Spinner(' skill status checking...');
    checkSkillStatusSpinner.start();

    apiWrapper.callGetSkillStatus(skillId, [CONSTANTS.SKILL.RESOURCES.MANIFEST], profile, doDebug, (data) => {
        checkSkillStatusSpinner.stop();
        if (data.statusCode === 404) {
            console.log('[Error] Skill not found.');
            process.exit();
        }
        let buildResponse = tools.convertDataToJsonObject(data.body);
        let skillStatusPathToStatus = [CONSTANTS.SKILL.RESOURCES.MANIFEST, 'lastUpdateRequest', 'status'];
        let status = jsonUtility.getPropertyValueFromObject(buildResponse, skillStatusPathToStatus);
        if (status === CONSTANTS.SKILL.BUILD_STATUS.IN_PROGRESS) {
            console.log('Skill build in progress. Please try again when previous build finishes.');
            process.exit();
        }
        callback();
    });
}

// Helper function to make the create skill succeed with current smapi requirement.
// This logic can be removed when the lambda validation check moves to skill submission.
function deleteInvalidEndpoint(preprocessedSkillSchema) {
    let manifest = JSON.parse(JSON.stringify(preprocessedSkillSchema));
    let domainKeyArray = domainRegistry.domainList().map((domain) => {
        return domainRegistry.getSkillSchemaKey(domain);
    });
    let apisInfo = manifest.manifest.apis;
    for (let domainKey of domainKeyArray) {
        // domain not existed or domain has no key inside, continue
        if (!apisInfo[domainKey] || Object.keys(apisInfo[domainKey]).length === 0) {
            continue;
        }
        // has default endpoint field but doesn't have anything inside, remove endpoint
        if (!apisInfo[domainKey].endpoint || Object.keys(apisInfo[domainKey].endpoint).length === 0) {
            let deletePathRegionLevel = [domainKey, 'endpoint'];
            jsonUtility.deletePropertyFromJsonObject(apisInfo, deletePathRegionLevel);
        }
        // has regions field but doesn't have any endpoints inside, remove regions
        if (!apisInfo[domainKey].regions || Object.keys(apisInfo[domainKey].regions).length === 0) {
            let deletePathRegionLevel = [domainKey, 'regions'];
            jsonUtility.deletePropertyFromJsonObject(apisInfo, deletePathRegionLevel);
        }

        // remove all the endpoint which is not absolute url for skill creation
        // default endpoint
        if (apisInfo[domainKey].hasOwnProperty('endpoint')) {
            let defaultEndpoint = apisInfo[domainKey].endpoint;
            if (!defaultEndpoint) {
                delete apisInfo[domainKey].endpoint;
            }
            if (defaultEndpoint.hasOwnProperty('uri') && !skillParser.isAbsoluteURL(defaultEndpoint.uri)) {
                let deletePath = [domainKey, 'endpoint'];
                jsonUtility.deletePropertyFromJsonObject(apisInfo, deletePath);
            }
        }
        // other regions' endpoints
        if (apisInfo[domainKey].hasOwnProperty('regions')) {
            let regionsInfo = apisInfo[domainKey].regions;
            for (let region of Object.keys(regionsInfo)) {
                let regionInfo = regionsInfo[region];
                if (regionInfo.hasOwnProperty('endpoint')) {
                    let endpointInfo = regionInfo.endpoint;
                    let deletePath = [domainKey, 'regions', region];
                    if (endpointInfo.hasOwnProperty('uri')) {
                        if (!skillParser.isAbsoluteURL(endpointInfo.uri)) {
                            jsonUtility.deletePropertyFromJsonObject(apisInfo, deletePath);
                        }
                    } else {
                        jsonUtility.deletePropertyFromJsonObject(apisInfo, deletePath);
                    }
                }
            }
            if (Object.keys(regionsInfo).length === 0) {
                jsonUtility.deletePropertyFromJsonObject(apisInfo, [domainKey, 'regions']);
            }
        }
    }
    manifest.manifest.apis = apisInfo;
    return manifest;
}


/**
 * check skill status with retry strategy,
 * callback with the final skill status after retry 5 times.
 *
 * @param skillId
 * @param profile
 * @param doDebug
 * @param callback
 * @return skill building status
 */
function pollingSkillStatus(skillId, profile, doDebug, callback) {
    // The maximum waiting time, which is the last time's polling will be:
    //   Math.min(minTimeout * Math.pow(1.2, 30), maxTimeout) ~= 8min
    // which is a good estimate for skill status polling
    let operation = retry.operation({
        retries: CONSTANTS.CONFIGURATION.RETRY.GET_MANIFEST_STATUS.MAX_RETRY,
        minTimeout: CONSTANTS.CONFIGURATION.RETRY.GET_MANIFEST_STATUS.MIN_TIME_OUT,
        factor: CONSTANTS.CONFIGURATION.RETRY.GET_MANIFEST_STATUS.FACTOR
    });

    let isRetryFinished = false;
    let response = {};
    operation.attempt(() => {
        apiWrapper.callGetSkillStatus(skillId, [CONSTANTS.SKILL.RESOURCES.MANIFEST], profile, doDebug, (data) => {
            // TODO Change 'needRetry' to the direct error given back by callGetSkillStatus when supported
            if (operation.retry(isRetryFinished ? null : 'needRetry')) {
                if (data.statusCode !== 404) {
                    let skillStatus = tools.convertDataToJsonObject(data.body);
                    response.status = jsonUtility.getPropertyValueFromObject(skillStatus, [CONSTANTS.SKILL.RESOURCES.MANIFEST, 'lastUpdateRequest', 'status']);
                    response.eTag = jsonUtility.getPropertyValueFromObject(skillStatus, [CONSTANTS.SKILL.RESOURCES.MANIFEST, 'eTag']);
                    if (response.status !== CONSTANTS.SKILL.BUILD_STATUS.IN_PROGRESS) {
                        callback(response);
                        isRetryFinished = true;
                    }
                }
            } 
            if (operation.attempts() === CONSTANTS.CONFIGURATION.RETRY.GET_MANIFEST_STATUS.MAX_RETRY) {
                response.status = CONSTANTS.SKILL.BUILD_STATUS.IN_PROGRESS;
                response.eTag = null;
                callback(response);
                isRetryFinished = true;
            }
        });
    });
}

function handleSkillStatus(response, skillId, profile, callback) {
    if (response.status === CONSTANTS.SKILL.BUILD_STATUS.SUCCESS) {
        ifMatchUtil.recordSkillEtag(response.eTag, profile);
        console.log('Skill Id: ' + skillId);
        console.log('Skill deployment finished.');
        if (typeof callback === 'function' && callback) {
            callback(skillId);
        }
    } else if (response.status === CONSTANTS.SKILL.BUILD_STATUS.IN_PROGRESS) {
        console.error('[Error]: Polling timeout. The skill is still in building progress.');
        return;
    } else {
        console.error('[Error]: Building skill schema failed');
        return;
    }
}
