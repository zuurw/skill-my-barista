'use strict';

const jsonfile = require('jsonfile');
const async = require('async');

const parser = require('../utils/skill-parser');
const profileHelper = require('../utils/profile-helper');
const jsonUtility = require('../utils/json-utility');
const domainRegistry = require('../utils/domain-registry');
const retrieveLambda = require('../utils/lambda-operation/retrieve-lambda');
const tools = require('../utils/tools');
const lambdaUtils = require('../resource/lambda-utils');

// Public
module.exports = {
    updateSkillSchemaWithLambdaCreation: updateSkillSchemaWithLambdaCreation,
    parseSkill: parseSkill
};

function updateSkillSchemaWithLambdaCreation(generatedLambdaList, submittingReadySkillSchema) {
    const finalSkillSchema = JSON.parse(JSON.stringify(submittingReadySkillSchema));
    if (!generatedLambdaList || generatedLambdaList.length === 0) {
        return finalSkillSchema;
    }
    for (let metaData of generatedLambdaList) {
        const region = lambdaUtils.getRegionFromAlexaUsage(metaData);
        const domainKey = domainRegistry.getSkillSchemaKey(lambdaUtils.getDomainFromAlexaUsage(metaData));
        const arrayPathToUri = ['manifest', 'apis', domainKey, 'regions', region, 'endpoint', 'uri'];
        jsonUtility.insertObjectToObject(finalSkillSchema, arrayPathToUri, metaData.arn);
    }
    // Logic to set one region as default.
    for (let domain of Object.keys(finalSkillSchema.manifest.apis)) {
        let domainInfo = finalSkillSchema.manifest.apis[domain];
        if (domainInfo.hasOwnProperty('endpoint')) {
            // If default region existed and need to create Lambda, replace it with real ARN
            if (domainInfo.regions.hasOwnProperty('default')) {
                domainInfo.endpoint.uri = domainInfo.regions.default.endpoint.uri;
                jsonUtility.deletePropertyFromJsonObject(domainInfo, ['regions', 'default']);
            }
        } else {
            // If NA exists move NA up; else move whatever comes the first
            let regionsKeyArray = Object.keys(domainInfo.regions);
            if (regionsKeyArray.indexOf('NA') === -1) {
                let firstRegion = domainInfo.regions[regionsKeyArray[0]];
                let defaultEndpoint = firstRegion.endpoint;
                domainInfo.endpoint = defaultEndpoint;
                jsonUtility.deletePropertyFromJsonObject(domainInfo, ['regions', regionsKeyArray[0]]);
            } else {
                let defaultEndpoint = domainInfo.regions.NA;
                domainInfo.endpoint = defaultEndpoint;
                jsonUtility.deletePropertyFromJsonObject(domainInfo, ['regions', 'NA']);
            }
        }
        // Clean empty regions if no endpoint inside
        if (Object.keys(domainInfo.regions) === 0) {
            jsonUtility.deletePropertyFromJsonObject(domainInfo, ['regions']);
        }
    }

    return finalSkillSchema;
}


function parseSkill(projectConfigFile, skillFile, profile, callback) {
    let manifest = jsonUtility.read(skillFile);

    if (!isValidManifest(manifest)) {
        console.error('Invalid skill manifest.');
        return;
    }

    let askConfig = jsonUtility.read(projectConfigFile);
    let skillName = parser.parseSkillName(manifest);
    if (!askConfig.deploy_settings[profile] || Object.keys(askConfig.deploy_settings[profile]).length === 0) {
        addNewProfileToConfig(askConfig, skillName, manifest, profile);
        jsonfile.writeFileSync(projectConfigFile, askConfig, {spaces: 2});
    }

    let skillId = jsonUtility.getPropertyValueFromObject(askConfig, ['deploy_settings', profile, 'skill_id']);

    // doing merge
    let mergedManifest = tools.collate(manifest, askConfig.deploy_settings[profile].merge);
    // move default endpoint under regions to treat it as regular endpoint
    moveDefaultEndpointIntoRegions(mergedManifest);
    // create file
    generateSubmittingReadyManifest(mergedManifest, profile, (preprocessedManifest) => {
        // this Manifest has sourceDir and url -> either true url, or functionName that need to be created.
        // which means if there is a functionName that can be find on AWS, it will change to the ARN.
        let withTrueURLManifest = tools.collate(mergedManifest, preprocessedManifest);
        
        moveDefaultEndpointUpBack(withTrueURLManifest);
        moveDefaultEndpointUpBack(preprocessedManifest);
        
        let skillInfo = parser.extractSkillInfo(withTrueURLManifest);

        callback(preprocessedManifest, skillInfo, skillId);
    });
}

function moveDefaultEndpointIntoRegions(mergedManifest) {
    let apisInfo = jsonUtility.getPropertyValueFromObject(mergedManifest, ['manifest', 'apis']);
    for (let domain of Object.getOwnPropertyNames(apisInfo)) {
        let domainInfo = apisInfo[domain];
        if (domainInfo.hasOwnProperty('endpoint')) {
            if (!domainInfo.hasOwnProperty('regions')) {
                domainInfo.regions = {};
            }
            domainInfo.regions.default = {
                endpoint: domainInfo.endpoint
            };
        }
    }
    return mergedManifest;
}

function generateSubmittingReadyManifest(mergedManifest, profile, callback) {
    let deepCopiedManifest = JSON.parse(JSON.stringify(mergedManifest));
    let awsProfile = profileHelper.getAWSProfile(profile);
    async.each(domainRegistry.domainList(), (domain, domainAsyncCallback) => {
        let domainKey = domainRegistry.getSkillSchemaKey(domain);
        let pathToRegions = ['manifest', 'apis', domainKey, 'regions'];
        let regionsInfo = jsonUtility.getPropertyValueFromObject(deepCopiedManifest, pathToRegions);
        if (!regionsInfo || Object.getOwnPropertyNames(regionsInfo).length === 0) {
            domainAsyncCallback();
            return;
        }
        async.each(Object.getOwnPropertyNames(regionsInfo), (region, regionLevelCallback) => {
            const currentUri = regionsInfo[region].endpoint.uri;
            const currentSourceDir = regionsInfo[region].endpoint.sourceDir;

            if (!currentUri || currentUri.trim().length === 0) {
                if (currentSourceDir && currentSourceDir.trim().length !== 0) {
                    // if no aws, no uri. we don't need sourceDir since we will not deploy lambda for the users.
                    if (!awsProfile) {
                        delete regionsInfo[region];
                    }
                    // not uri, has sourceDir, will create lambda using the codebase.
                    regionLevelCallback();
                } else {
                    // no uri, no sourceDir but has endpoint filed
                    regionLevelCallback('[Error]: Invalid uri info.\n' +
                        'Please check "skill.json" and ".ask/config" files and set your endpoint information correctly.');
                }
                return;
            }
        
            if (!parser.isAbsoluteURL(currentUri)) {
                // if not correct URL, delete them if no aws in the profile.
                if (!awsProfile) {
                    delete regionsInfo[region];
                    regionLevelCallback();
                    return;
                }

                // has uri, but not real ARN, call aws to check if there is a real ARN binded with this functionName
                retrieveLambda.retrieveLambdaFunction(currentUri, region, awsProfile, (awsResponseURL) => {
                    if (awsResponseURL && awsResponseURL.substr(0, 4) === 'arn:') {
                        let arrayPathToUri = [region, 'endpoint', 'uri'];
                        jsonUtility.insertObjectToObject(regionsInfo, arrayPathToUri, awsResponseURL);
                    }
                    // if use function name cannot find lambda function, and not sourceDir, stop the process
                    if (!currentSourceDir || currentSourceDir.trim().length === 0) {
                        regionLevelCallback('[Error]: Invalid url info.\n' +
                            'Cannot find valid lambda function with the given name, ' +
                            'nor find sourceDir as codebase path to create lambda function.');
                        return;
                    }
                    regionLevelCallback();
                    return;
                });
            } else {
                // if aws says no function with this function name, treat as create new lambda.
                // so uri won't change here
                regionLevelCallback();
                return;
            }
        }, (err) => {
            if (err) {
                domainAsyncCallback(err);
            }
            domainAsyncCallback();
        });
    }, (err) => {
        if (err) {
            console.error(err);
            process.exit(1);
        }
        obtainUniqueness(deepCopiedManifest, (approvedManifest) => {
            callback(approvedManifest);
        });
    });
}

// check whether multiple different code bases map to a single lambda uri, and remove 'sourceDir' and pass to callback.
function obtainUniqueness(manifest, callback) {
    let checkUniqueMap = new Map();
    let domainKeyArray = domainRegistry.domainList().map((domain) => {
        return domainRegistry.getSkillSchemaKey(domain);
    });
    for (let domainKey of domainKeyArray) {
        if (!manifest.manifest.apis[domainKey] || !manifest.manifest.apis[domainKey].regions) {
            continue;
        }
        let regionsInfo = manifest.manifest.apis[domainKey].regions;
        for (let region of Object.getOwnPropertyNames(regionsInfo)) {
            let uri = regionsInfo[region].endpoint.uri;
            if (!uri) {
                continue;
            }
            let deletePath = ['manifest', 'apis', domainKey, 'regions', region, 'endpoint', 'sourceDir'];
            if (uri.substr(0,4) !== 'arn:') {
                // it's a function name, which aws don't have a function match with
                jsonUtility.deletePropertyFromJsonObject(manifest, deletePath);
                continue;
            }
            let sourceDir = regionsInfo[region].endpoint.sourceDir;
            if (!sourceDir || sourceDir.length === 0) {
                continue;
            }
            if (!checkUniqueMap.get(uri)) {
                checkUniqueMap.set(uri, sourceDir);
            } else if (sourceDir !== checkUniqueMap.get(uri)) {
                console.error('Multiple source directory point to a same endpoint.');
                process.exit(1);
            }
            jsonUtility.deletePropertyFromJsonObject(manifest, deletePath);
        }
    }
    callback(manifest);
}

function moveDefaultEndpointUpBack(manifest) {
    let apisInfo = jsonUtility.getPropertyValueFromObject(manifest, ['manifest', 'apis']);
    for (let domain of Object.getOwnPropertyNames(apisInfo)) {
        if (apisInfo[domain].hasOwnProperty('regions')) {
            apisInfo[domain].endpoint = jsonUtility.getPropertyValueFromObject(
                apisInfo, [domain, 'regions', 'default', 'endpoint']);
            jsonUtility.deletePropertyFromJsonObject(apisInfo, [domain, 'regions', 'default']);
            // Remove "regions" field if there is no region inside
            if (Object.keys(apisInfo[domain].regions).length === 0) {
                jsonUtility.deletePropertyFromJsonObject(apisInfo, [domain, 'regions']);
            }
        }
    }
}

function addNewProfileToConfig(askConfig, skillName, manifest, profile) {
    let domainList = parser.parseDomainList(manifest);
    askConfig.deploy_settings[profile] = {
        skill_id: '',
        was_cloned: false,
        merge: {
            manifest: {
                apis: {
                }
            }
        }
    };

    for (let domain of domainList) {
        let targetPath = ['deploy_settings', profile, 'merge', 'manifest', 'apis', domain];
        jsonUtility.insertObjectToObject(askConfig, targetPath, {});
    }

    let awsProfile = profileHelper.getAWSProfile(profile);
    if (!awsProfile) {
       return;
    }

    for (let domain of domainList) {
        if (domainRegistry.domainList().indexOf(domain) === -1) {
            continue;
        }

        let apisPath = ['manifest', 'apis', domain];
        let domainInfo = jsonUtility.getPropertyValueFromObject(manifest, apisPath);

        if (!domainInfo || Object.keys(domainInfo).length === 0) {
            continue;
        } else {
            // TODO: If endpoint has not only default endpoint, or endpoint is not lambda type, 
            // this will be wrong as it creates uri as a Lambda function name.
            let domainObject = {
                endpoint: {
                    uri: "ask-" + domain + "-" + skillName + "-" + profile
                }
            };
            let addPath = ['deploy_settings', profile, 'merge', 'manifest', 'apis', domain];
            jsonUtility.insertObjectToObject(askConfig, addPath, domainObject);
        }
    }
}

// a basic validation for skill.json
// to check whether it has manifest or not
function isValidManifest(skillSchema) {
    if (skillSchema &&
        skillSchema.manifest &&
        typeof skillSchema.manifest === 'object')
    {
        return true;
    }
    else {
        return false;
    }
}
