'use strict';

const async = require('async');
const fs = require('fs');
const jsonfile = require('jsonfile');
const displayUtil = require('../utils/display-utility');
const ispUtil = require('../utils/isp-utils/isp-utility');
const apiWrapper = require('../api/api-wrapper');
const ispConstants = require('../utils/isp-utils/isp-constants');
const pullISPUtil = require('../utils/isp-utils/pull-isp');

module.exports = {
    deployISPProcess: deployISPProcess,
    deployISP: deployISP,
    getISPDeployCollections: getISPDeployCollections,
};

/**
 * Deploy ISP for given skill project and update the skill config file
 * @param skillId the skill id
 * @param skillProjectPath the root path of the skill project
 * @param forceDeployment force the in-skill products deployment without checkout ETags
 * @param profile the ASK CLI user profile
 * @param doDebug the ASK CLI debug mode
 * @param callback the callback function to handle the response
 */
function deployISP(skillId, skillProjectPath, forceDeployment, profile, doDebug, callback) {
    deployISPProcess(skillId, skillProjectPath, forceDeployment, profile, doDebug, (deployISPError, ispConfigList, deployedISPs) => {
        if (ispConfigList) {
            ispUtil.replaceISPConfigs(skillProjectPath, profile, ispConfigList);
        }
        pullDeployedISPs(deployedISPs, skillProjectPath, profile, doDebug, (syncISPError) => {
            if (deployISPError) {
                console.error('In-skill product deployment failed.');
            } else {
                if (!deployedISPs) {
                    console.log("No in-skill product to be deployed.");
                } else {
                    console.log('In-skill product deployment finished.');
                }
            }
            printDeployedISPResults(deployedISPs);
            printErrors(deployISPError);
            printErrors(syncISPError);
            callback();
        });
    });
}

/**
 * Helper function to deploy in-skill products
 * @param skillId the skill id
 * @param skillProjectPath the root path of the skill project
 * @param forceDeployment
 * @param profile the ASK CLI user profile
 * @param doDebug the ASK CLI debug mode
 * @param callback the callback function to handle the response
 */
function deployISPProcess(skillId, skillProjectPath, forceDeployment, profile, doDebug, callback) {
    if (!skillId) {
        callback('No skill Id found in the current skill project. Use "ask deploy" to deploy in-skill product with skill if the skill has not been deployed yet.');
        return;
    }

    if (!skillProjectPath || !fs.existsSync(skillProjectPath)) {
        callback('Skill project path does not exist.');
        return;
    }

    getISPDeployCollections(skillProjectPath, forceDeployment, profile, (deployCollectionsError, deployCollections) => {
        let ispConfigList = [];
        if (deployCollectionsError) {
            callback(deployCollectionsError);
            return;
        }
        if (deployCollections.error && deployCollections.error.length > 0) {
            console.warn('\nError(s) found in the deploy setting for the following in-skill product(s):');
            console.log('    (Please restore the missing file or modify skill configuration file ' + ispUtil.getConfigPath('') + ' to fix the deploy setting)\n');
            deployCollections.error.forEach(ispObject => {
                console.log(ispObject.error + ': [ID] ' + ispObject.productId + '  [FILE] ' + ispObject.filePath);
                addISPConfigInfo(ispConfigList, ispObject.deploy_status, ispObject.filePath, ispObject.productId, ispObject.eTag);
            });
            console.log();
        }
        if (deployCollections.disassociate.length === 0 &&
            deployCollections.update.length === 0 &&
            deployCollections.create.length === 0 &&
            deployCollections.associate.length === 0) {
            callback(null, ispConfigList);
            return;
        }
        /**
         * Update the ISP before association to make sure the latest version of ISP is being associated
         */
        if (deployCollections.associate.length > 0) {
            deployCollections.update = deployCollections.update.concat(deployCollections.associate);
        }

        updateISP(deployCollections.update, skillId, forceDeployment, profile, doDebug, (updateISPError, updatedISPList, updateISPConfigList) => {
            ispConfigList = ispConfigList.concat(updateISPConfigList);
            if (updateISPError) {
                ispConfigList = ispConfigList.concat(deployCollections.create, deployCollections.disassociate);
                callback(updateISPError, ispConfigList, {
                    updated: updatedISPList
                });
                return;
            }
            createISP(deployCollections.create, profile, doDebug, (createISPError, createdISPList, createISPConfigList) => {
                if (createISPError) {
                    ispConfigList = ispConfigList.concat(createISPConfigList, deployCollections.associate, deployCollections.disassociate);
                    callback(createISPError, ispConfigList, {
                        updated: updatedISPList,
                        created: createdISPList
                    });
                    return;
                }
                /**
                 * Associate the created ISPs
                 */
                if (createdISPList.length > 0) {
                    deployCollections.associate = deployCollections.associate.concat(createdISPList);
                }
                associateISP(deployCollections.associate, skillId, profile, doDebug, (associateISPError, associatedISPList, associateISPConfigList) => {
                    ispConfigList = ispConfigList.concat(associateISPConfigList);
                    if (associateISPError) {
                        ispConfigList = ispConfigList.concat(deployCollections.disassociate);
                        callback(associateISPError, ispConfigList, {
                            updated: updatedISPList,
                            created: createdISPList,
                            associated: associatedISPList
                        });
                        return;
                    }
                    disassociateISP(deployCollections.disassociate, skillId, profile, doDebug, (disassociateISPError, disassociatedISPList, disassociatedISPConfigList) => {
                        ispConfigList = ispConfigList.concat(disassociatedISPConfigList);
                        callback(disassociateISPError, ispConfigList, {
                            updated: updatedISPList,
                            created: createdISPList,
                            associated: associatedISPList,
                            removed: disassociatedISPList
                        });
                    });
                });
            });
        });
    });
}

//Private
/**
 * Create in-skill products
 * @param ispListToCreate a list of in-skill product to be created
 * @param profile the ASK CLI user profile
 * @param doDebug ASK CLI debug mode
 * @param callback the callback function to handle the response
 */
function createISP(ispListToCreate, profile, doDebug, callback) {
    const createdISPList = [];
    const errorList = [];
    const ispConfigList = [];

    if (!ispListToCreate || ispListToCreate.length === 0) {
        callback(null, createdISPList, ispConfigList);
        return;
    }
    const createSpinner = new displayUtil.Spinner('Creating in-skill product(s)...');
    createSpinner.start();
    async.eachSeries(
        ispListToCreate,
        (ispConfig, eachCallback) => {
            setTimeout(() => {
                jsonfile.readFile(ispConfig.filePath, {throws: true}, (jsonFileError, ispDefinition) => {
                    if (jsonFileError || !ispDefinition) {
                        addErrorInfo(errorList, ispConstants.API.CREATE_ISP, ispConstants.ERROR.INVALID_ISP_FILE, ispConfig.filePath);
                        ispConfigList.push(ispConfig);
                        eachCallback();
                        return;
                    }
                    let vendorId = ispUtil.getVendorIDFromProfile(profile);
                    apiWrapper.callCreateISP(vendorId, ispDefinition, profile, doDebug, (createISPError, responseBody) => {
                        if (createISPError || !responseBody || !responseBody.productId) {
                            let errorMessage = createISPError ? createISPError : 'Cannot get in-skill product Id from service response';
                            addErrorInfo(errorList, ispConstants.API.CREATE_ISP, errorMessage, ispConfig.filePath);
                            ispConfigList.push(ispConfig);
                            eachCallback();
                            return;
                        }
                        addISPConfigInfo(createdISPList, ispConstants.DEPLOY_STATUS.ASSOCIATE, ispConfig.filePath, responseBody.productId);
                        addISPConfigInfo(ispConfigList, ispConstants.DEPLOY_STATUS.ASSOCIATE, ispConfig.filePath, responseBody.productId);
                        eachCallback();
                    });
                });
            }, ispConstants.NUMBERS.TIME_INTERVAL_FOR_ASYNC_REQUEST);
        },
        () => {
            createSpinner.stop();
            if (errorList.length > 0) {
                callback({
                    message: 'Failed to create in-skill product(s)',
                    errorList: errorList
                }, createdISPList, ispConfigList);
                return;
            }
            callback(null, createdISPList, ispConfigList);
        }
    );
}

/**
 * Associate in-skill product
 * @param ispListToAssociate list of in-skill products that are going to be associated to skill
 * @param skillId the skill ID
 * @param profile ASK CLI user profile
 * @param doDebug ASK CLI debug mode
 * @param callback the callback function to handle the response
 */
function associateISP(ispListToAssociate, skillId, profile, doDebug, callback) {
    const associatedISPList = [];
    const ispConfigList = [];
    const errorList = [];
    if (!ispListToAssociate || ispListToAssociate.length === 0) {
        callback(null, associatedISPList, ispConfigList);
        return;
    }
    const associateSpinner = new displayUtil.Spinner('Associating in-skill product(s)...');
    associateSpinner.start();
    async.eachSeries(
        ispListToAssociate,
        (ispConfig, eachCallback) => {
            setTimeout(() => {
                apiWrapper.callAssociateISP(ispConfig.productId, skillId, profile, doDebug, (associateISPError) => {
                    if (associateISPError) {
                        addErrorInfo(errorList, ispConstants.API.ASSOCIATE_ISP, associateISPError, ispConfig.filePath, ispConfig.productId);
                        addISPConfigInfo(ispConfigList, ispConstants.DEPLOY_STATUS.ASSOCIATE, ispConfig.filePath, ispConfig.productId);
                        eachCallback();
                        return;
                    }
                    addISPConfigInfo(associatedISPList, ispConstants.DEPLOY_STATUS.UPDATE, ispConfig.filePath, ispConfig.productId);
                    addISPConfigInfo(ispConfigList, ispConstants.DEPLOY_STATUS.UPDATE, ispConfig.filePath, ispConfig.productId);
                    eachCallback();
                });
            }, ispConstants.NUMBERS.TIME_INTERVAL_FOR_ASYNC_REQUEST);
        },
        () => {
            associateSpinner.stop();
            if (errorList.length > 0) {
                callback({
                    message: 'Failed to associate in-skill product(s)',
                    errorList: errorList
                }, associatedISPList, ispConfigList);
                return;
            }
            callback(null, associatedISPList, ispConfigList);
        }
    );
}

/**
 * Update in-skill products
 * @param ispListToUpdate a list of in-skill product to be updated
 * @param skillId the skill ID
 * @param forceDeployment force the in-skill products deployment without checkout ETags
 * @param profile ASK CLI user profile
 * @param doDebug ASK CLI debug mode
 * @param callback the callback function to handle the response
 */
function updateISP(ispListToUpdate, skillId, forceDeployment, profile, doDebug, callback) {
    const updatedISPList = [];
    const ispConfigList = [];
    const errorList = [];
    if (!ispListToUpdate || ispListToUpdate.length === 0) {
        callback(null, updatedISPList, ispConfigList);
        return;
    }
    const updateSpinner = new displayUtil.Spinner('Updating in-skill product(s)...');
    updateSpinner.start();

    async.eachSeries(
        ispListToUpdate,
        (ispConfig, eachCallback) => {
            setTimeout(() => {
                if (!ispConfig.filePath) {
                    addErrorInfo(errorList, ispConstants.API.UPDATE_ISP, ispConstants.ERROR.INVALID_CONFIG_MISSING_FILE, null, ispConfig.filePath);
                    ispConfigList.push(ispConfig);
                    eachCallback();
                    return;
                }
                jsonfile.readFile(ispConfig.filePath, {throws: true}, (jsonFileError, ispDefinition) => {
                    if (jsonFileError || !ispDefinition) {
                        addErrorInfo(errorList, ispConstants.API.UPDATE_ISP, ispConstants.ERROR.INVALID_ISP_FILE, ispConfig.filePath, ispConfig.productId);
                        ispConfigList.push(ispConfig);
                        eachCallback();
                        return;
                    }
                    apiWrapper.callUpdateISP(ispConfig.productId, ispDefinition, ispConstants.ISP_STAGE.DEVELOPMENT, profile, (forceDeployment ? null : ispConfig.eTag), doDebug, (updateISPError) => {
                        if (updateISPError) {
                            addErrorInfo(errorList, ispConstants.API.UPDATE_ISP, updateISPError, ispConfig.filePath, ispConfig.productId);
                            ispConfigList.push(ispConfig);
                            eachCallback();
                            return;
                        }
                        addISPConfigInfo(updatedISPList, ispConstants.DEPLOY_STATUS.UPDATE, ispConfig.filePath, ispConfig.productId);
                        if (ispConfig.deploy_status && ispConfig.deploy_status === ispConstants.DEPLOY_STATUS.UPDATE) {
                            ispConfigList.push(ispConfig);
                        }
                        eachCallback();
                    });
                });
            }, ispConstants.NUMBERS.TIME_INTERVAL_FOR_ASYNC_REQUEST);
        },
        () => {
            updateSpinner.stop();
            if (errorList.length > 0) {
                callback({
                    message: 'Failed to update in-skill product(s)',
                    errorList: errorList
                }, updatedISPList, ispConfigList);
                return;
            }
            callback(null, updatedISPList, ispConfigList);
        }
    );
}

/**
 * Disassociate in-skill products
 * @param ispListToDisassociate a list of in-skill product IDs to be disassociated
 * @param skillId the skill ID
 * @param profile the ASK CLI user profile
 * @param doDebug ASL CLI debug mode
 * @param callback the callback function to handle the response
 */
function disassociateISP(ispListToDisassociate, skillId, profile, doDebug, callback) {
    const disassociatedISPList = [];
    const ispConfigList = [];
    const errorList = [];
    if (!ispListToDisassociate || ispListToDisassociate.length === 0) {
        callback(null, disassociatedISPList, ispConfigList);
        return;
    }
    const disassociateSpinner = new displayUtil.Spinner('Removing in-skill product(s)...');
    disassociateSpinner.start();

    async.eachSeries(
        ispListToDisassociate,
        (ispConfig, eachCallback) => {
            setTimeout(() => {
                apiWrapper.callDisassociateISP(ispConfig.productId, skillId, profile, doDebug, (disassociateISPError) => {
                    if (disassociateISPError) {
                        addErrorInfo(errorList, ispConstants.API.DISASSOCIATE_ISP, disassociateISPError, ispConfig.filePath, ispConfig.productId);
                        ispConfigList.push(ispConfig);
                        eachCallback();
                        return;
                    }
                    addISPConfigInfo(disassociatedISPList, ispConstants.DEPLOY_STATUS.REMOVE, ispConfig.filePath, ispConfig.productId);
                    eachCallback();
                });
            }, ispConstants.NUMBERS.TIME_INTERVAL_FOR_ASYNC_REQUEST);
        },
        () => {
            disassociateSpinner.stop();
            if (disassociatedISPList.length > 0) {
                disassociatedISPList.forEach((isp) => {
                    if (isp.filePath) {
                        fs.unlinkSync(isp.filePath);
                    }
                });
            }
            if (errorList.length > 0) {
                callback({
                    message: 'Failed to remove in-skill product(s)',
                    errorList: errorList
                }, disassociatedISPList, ispConfigList);
                return;
            }
            callback(null, disassociatedISPList, ispConfigList);
        }
    );
}

/**
 * Get the in-skill product deployment collections
 * @param skillProjectPath the root path of skill project
 * @param forceDeployment force in-skill product deployment without the validation of eTag
 * @param profile the ASK CLI user profile
 * @param callback the callback function to handle response
 */
function getISPDeployCollections(skillProjectPath, forceDeployment, profile, callback) {
    if (!skillProjectPath || !fs.existsSync(skillProjectPath)) {
        callback('Failed to get in-skill product deployment settings since the skill project path is invalid.');
        return;
    }
    const disassociateISPList = [];
    const updateISPList = [];
    const associateISPList = [];
    const createISPList = [];
    const errorISPList = [];
    const ispInfoMap = new Map();
    const ispConfigList = ispUtil.getISPConfigs(skillProjectPath, profile);
    if (!ispConfigList || ispConfigList.length === 0) {
        callback(null, {
            create: createISPList,
            update: updateISPList,
            associate: associateISPList,
            disassociate: disassociateISPList,
            error: errorISPList
        }, ispInfoMap);
        return;
    }

    for (let ispConfig of ispConfigList) {
        let isISPConfigValid = true;
        let ispDefinition;
        if (!ispConfig.filePath || !fs.existsSync(ispConfig.filePath)) {
            addErrorInfo(errorISPList, null, ispConstants.ERROR.INVALID_CONFIG_MISSING_FILE, ispConfig.filePath, ispConfig.productId, ispConfig.eTag, ispConfig.deploy_status);
            isISPConfigValid = false;
        } else {
            ispDefinition = jsonfile.readFileSync(ispConfig.filePath, {throws: false});
            if (!ispDefinition) {
                addErrorInfo(errorISPList, null, ispConstants.ERROR.INVALID_ISP_FILE, ispConfig.filePath, ispConfig.productId, ispConfig.eTag, ispConfig.deploy_status);
                isISPConfigValid = false;
            } else if (!ispUtil.isISPPurchasableStateValid(ispDefinition.purchasableState)) {
                addErrorInfo(errorISPList, null, ispConstants.ERROR.INVALID_ISP_PURCHASABLE_STATE, ispConfig.filePath, ispConfig.productId, ispConfig.eTag, ispConfig.deploy_status);
                isISPConfigValid = false;
            } else {
                ispInfoMap.set(ispConfig.filePath, {
                    purchasableState: ispDefinition.purchasableState
                });
            }
        }

        if (!ispUtil.isISPConfigDeployStatusValid(ispConfig.deploy_status)) {
            addErrorInfo(errorISPList, null, ispConstants.ERROR.INVALID_CONFIG_INVALID_STATUS, ispConfig.filePath, ispConfig.productId, ispConfig.eTag, ispConfig.deploy_status);
            isISPConfigValid = false;
        }
        if ((ispConfig.deploy_status !== ispConstants.DEPLOY_STATUS.ADD) && (!ispConfig.productId)) {
            addErrorInfo(errorISPList, null, ispConstants.ERROR.INVALID_CONFIG_MISSING_ID, ispConfig.filePath, null, ispConfig.eTag, ispConfig.deploy_status);
            isISPConfigValid = false;
        }
        if(!forceDeployment && ispConfig.deploy_status === ispConstants.DEPLOY_STATUS.UPDATE && !ispConfig.eTag){
            addErrorInfo(errorISPList, null, ispConstants.ERROR.INVALID_CONFIG_MISSING_ETAG, ispConfig.filePath, ispConfig.productId, ispConfig.eTag, ispConfig.deploy_status);
            isISPConfigValid = false;
        }

        if (!isISPConfigValid) {
            continue;
        }

        if (ispConfig.deploy_status === ispConstants.DEPLOY_STATUS.UPDATE) {
            updateISPList.push(ispConfig);
        } else if (ispConfig.deploy_status === ispConstants.DEPLOY_STATUS.ADD) {
            createISPList.push(ispConfig);
        } else if (ispConfig.deploy_status === ispConstants.DEPLOY_STATUS.REMOVE) {
            disassociateISPList.push(ispConfig);
        } else if (ispConfig.deploy_status === ispConstants.DEPLOY_STATUS.ASSOCIATE) {
            associateISPList.push(ispConfig);
        }
    }
    callback(null,
        {
            create: createISPList,
            update: updateISPList,
            associate: associateISPList,
            disassociate: disassociateISPList,
            error: errorISPList
        }, ispInfoMap);
}

/**
 * Pull the deployed in-skill products to ensure the ETag and contents are update-to-date
 * @param deployedISPs collections of deployed in-skill products
 * @param skillProjectPath root path to the skill project
 * @param profile ASK CLI user profile
 * @param doDebug ASK CLI debug mode
 * @param callback callback to handle the response
 */
function pullDeployedISPs(deployedISPs, skillProjectPath, profile, doDebug, callback) {
    if (!deployedISPs) {
        return;
    }
    const spinner = displayUtil.Spinner("Pulling deployed in-skill product(s) version information...");
    spinner.start();

    const createdISPList = deployedISPs.created || [];
    const updatedISPList = deployedISPs.updated || [];
    const deployedISPConfigList = createdISPList.concat(updatedISPList);
    const ispSetToPull = new Set();
    deployedISPConfigList.forEach((ispConfig) => ispSetToPull.add(ispConfig.productId));
    pullISPUtil.pullISP(ispSetToPull, skillProjectPath, profile, doDebug, (pullISPError) => {
        spinner.stop();
        if (pullISPError) {
            callback('Failed to pull deployed in-skill product(s) version information.');
            return;
        }
        callback();
    });
}

/**
 * Print the deployed in-skill products
 * @param deployedISP object contains the deployed ISP results
 */
function printDeployedISPResults(deployedISP) {
    if (!deployedISP) {
        return;
    }
    const actionList = ['updated', 'created', 'associated', 'removed'];
    for (let action of actionList) {
        if (deployedISP[action] && deployedISP[action].length > 0) {
            console.log('In-skill product(s) ' + action + ':');
            const ispList = deployedISP[action];
            ispList.forEach(isp => {
                console.log('  [ID] ' + isp.productId + ' [FILE] ' + isp.filePath);
            });
        }
    }
}

/**
 * Print the errors
 * @param errorObject object contains error information
 */
function printErrors(errorObject) {
    if (!errorObject) {
        return;
    }
    if (typeof errorObject === 'string') {
        console.error(ispUtil.getFormattedErrorString(errorObject));
        return;
    }
    if (errorObject.message) {
        console.error('\n' + errorObject.message + ':');
    }
    if (errorObject.errorList && errorObject.errorList.length > 0) {
        errorObject.errorList.forEach((error) => {
            if (error.apiName) {
                if (error.apiName === ispConstants.API.CREATE_ISP) {
                    console.error('[FILE] ' + error.filePath);
                } else {
                    console.error('[ID] ' + error.productId + ' [FILE] ' + error.filePath);
                }
            }
            console.error(ispUtil.getFormattedErrorString(error.error) + '\n');
        });
    }
}

/**
 * Generate error information
 * @param errorList list contains errors
 * @param apiName name of the ISP API
 * @param error error message
 * @param filePath path of the ISP file
 * @param productId ISP product ID
 * @param eTag the ETag of the ISP
 * @param deployStatus the deploy status of ISP
 */
function addErrorInfo(errorList, apiName, error, filePath, productId, eTag, deployStatus) {
    if (error || filePath || productId) {
        const errorObject = {};
        if (error) {
            errorObject.error = error;
        }
        if (apiName) {
            errorObject.apiName = apiName;
        }
        if (productId) {
            errorObject.productId = productId;
        }
        if (filePath) {
            errorObject.filePath = filePath;
        }
        if (eTag) {
            errorObject.eTag = eTag;
        }
        if (deployStatus) {
            errorObject.deploy_status = deployStatus;
        }
        if (errorList && Object.prototype.toString.call(errorList) === '[object Array]') {
            errorList.push(errorObject);
        }
        return errorObject;
    }
    return null;
}

/**
 * Generate isp configuration
 * @param ispConfigList list of isp configuration objects
 * @param deployStatus the status of the isp deployment
 * @param filePath (Required) the path to the ISP file
 * @param productId the product ID of ISP
 * @param eTag of the ISP
 */
function addISPConfigInfo(ispConfigList, deployStatus, filePath, productId, eTag) {
    if (!filePath) {
        return null;
    }
    const ispConfig = {};
    if (deployStatus) {
        ispConfig.deploy_status = deployStatus;
    }
    if (filePath) {
        ispConfig.filePath = filePath;
    }
    if (productId) {
        ispConfig.productId = productId;
    }
    if (eTag) {
        ispConfig.eTag = eTag;
    }
    if (ispConfigList && Object.prototype.toString.call(ispConfigList) === '[object Array]') {
        ispConfigList.push(ispConfig);
    }
    return ispConfig;
}
