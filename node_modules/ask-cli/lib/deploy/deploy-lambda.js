'use strict';

const createLambda = require('../utils/lambda-operation/create-lambda');
const updateLambda = require('../utils/lambda-operation/update-lambda');
const profileHelper = require('../utils/profile-helper');
const installNodeModule = require('../utils/install-node-module');
const ifMatchUtil = require('../utils/if-match-utility');
const jsonUtility = require('../utils/json-utility');
const lambdaEndpointUtil = require('../utils/lambda-operation/lambda-endpoint-utility');
const CONSTANTS = require('../utils/constants');

module.exports = {
    deployLambda: deployLambda
};

function deployLambda(skillId, skillInfo, forceDeployment, profile, doDebug, callback) {
    if (!skillId) {
        console.error('No skill ID found. Please first create skill, then deploy lambda.');
        process.exit(1);
    }

    let awsProfile = profileHelper.getAWSProfile(profile);
    if (!awsProfile) {
        console.warn('[Warn]: Lambda deployment skipped because AWS credentials for profile [' +
            profile + '] are missing. CLI lambda functionalities can be' +
            " enabled by running `ask init` again to add 'aws_profile' to ASK cli_config");
        if (typeof callback === 'function' && callback) {
            callback();
        }
        return;
    }

    lambdaEndpointUtil.separateLambdaCreateUpdate(skillInfo.skillName, skillInfo.endpointsInfo, './', profile, (err, lambdaList) => {
        if (err) {
            console.error(err);
            process.exit(1);
        }

        let updateLambdaList = lambdaList.updateLambdaList;
        let createLambdaList = lambdaList.createLambdaList;
        if (updateLambdaList.length === 0 && createLambdaList.length === 0) {
            console.log('[Info]: No lambda functions need to be deployed.');
            callback();
            return;
        }

        installNodeModule.install(createLambdaList, updateLambdaList, process.cwd(), doDebug, () => {
            createLambda.createLambda(skillId, skillInfo.skillName, createLambdaList, awsProfile, (createdLambdaMetaDataList) => {
                _fillUpInfoFromResourcesConfig(updateLambdaList, profile);
                updateLambda.updateLambda(updateLambdaList, awsProfile, forceDeployment, (updatedLambdaMetaDataList) => {
                    // record new lambda revision ids
                    // create list need deep copied since the function will remove some properties from this step which will be used in downstream.
                    if (createLambdaList.length !== 0) {
                        ifMatchUtil.recordLambdaRevisionId(JSON.parse(JSON.stringify(createdLambdaMetaDataList)), profile);
                    }
                    if (updateLambdaList.length !== 0) {
                        ifMatchUtil.recordLambdaRevisionId(updatedLambdaMetaDataList, profile);
                    }
    
                    console.log('Lambda deployment finished.');
                    printLambdaDeployResults(createLambdaList,updateLambdaList);
                    if (typeof callback === 'function' && callback) {
                        callback(createdLambdaMetaDataList);
                    }
                });
            });
        });
    });
}

function printLambdaDeployResults(createLambdaList, updateLambdaList){
    if (createLambdaList && createLambdaList.length > 0) {
        console.log('Lambda function(s) created:');
        createLambdaList.forEach(metaData => {
            console.log('  [Lambda ARN] ' + metaData.arn);
        });
    }
    if (updateLambdaList && updateLambdaList.length > 0) {
        console.log('Lambda function(s) updated:');
        updateLambdaList.forEach(metaData => {
            console.log('  [Lambda ARN] ' + metaData.arn);
        });
    }
}

function _fillUpInfoFromResourcesConfig(updateLambdaList, profile) {
    if (!updateLambdaList || updateLambdaList.length === 0) { 
        return;
    }
    const lambdaResourcePath = ['deploy_settings', profile, 'resources', 'lambda'];
    const lambdaListFromResources = jsonUtility.getProperty(CONSTANTS.FILE_PATH.PROJECT_CONFIG_PATH(process.cwd()), lambdaResourcePath);
    if (!lambdaListFromResources || lambdaListFromResources.length === 0) {
        return;
    }

    for (let updateLambdaMetaData of updateLambdaList) {
        for (let resourceLambdaMetaData of lambdaListFromResources) {
            if (updateLambdaMetaData.arn === lambdaEndpointUtil.removeLATESTFromArn(resourceLambdaMetaData.arn)) {
                for (let key of Object.keys(resourceLambdaMetaData)) {
                    if (!updateLambdaMetaData[key] || updateLambdaMetaData[key].length === 0) {
                        // need deep copy
                        updateLambdaMetaData[key] = JSON.parse(JSON.stringify(resourceLambdaMetaData[key]));
                    }
                }
                break;
            }
        }
    }
}
