'use strict';

const apiWrapper = require('./api-wrapper');
const tools = require('../utils/tools');
const inquirer = require('inquirer');
const profileHelper = require('../utils/profile-helper');
const jsonUtility = require('../utils/json-utility');
const CONSTANTS = require('../utils/constants');
const fs = require('fs');

const ACCOUNT_LINKING_REQUEST = 'accountLinkingRequest';

// Public
module.exports = {
    createCommand: (commander) => {
        buildCreateAccountLinkingCommand(commander);
        buildGetAccountLinkingCommand(commander);
        buildDeleteAccountLinkingCommand(commander);
    }
};

// Private
function buildCreateAccountLinkingCommand(commander) {
    commander
        .command('create-account-linking')
        .usage('<-s|--skill-id <skill-id>> [-g|--stage <stage>] [-f|--file <file>] [-p|--profile <profile>] [--debug]')
        .description('create/update account linking configuration for a skill')
        .option('-s, --skill-id <skill-id>', 'skill-id for the skill')
        .option('-g, --stage <stage>', 'stage for the skill')
        .option('-f, --file <file>', 'upload in the format of account linking schemas')
        .option('-p, --profile <profile>', 'ask cli profile')
        .option('--debug', 'ask cli debug mode')
        .action(handle);

    function handle(options) {
        if (!options.skillId) {
            console.error('Please input required parameter: skill-id.');
            process.exit(1);
        }
        let stage = options.stage || CONSTANTS.SKILL.STAGE.DEVELOPMENT;
        let profile = profileHelper.runtimeProfile(options.profile);

        if (typeof options.file === 'string') {
            if (options.file.length <= 0 || !fs.existsSync(options.file)) {
                console.error('[Error]: Please verify the file path for account linking schema is correct.');
                process.exit(1);
            }
            const accountLinking = jsonUtility.read(options.file);
            if (!accountLinking || Object.keys(accountLinking).length !== 1 || !accountLinking.hasOwnProperty(ACCOUNT_LINKING_REQUEST)) {
                console.error('[Error]: Account linking schema is not under correct format. Please turn to ' + 
                    'https://developer.amazon.com/docs/smapi/account-linking-schemas.html#accountlinkingrequest-object for reference.');
                process.exit(1);
            }
            apiWrapper.callCreateAccountLinking(options.skillId, stage, accountLinking[ACCOUNT_LINKING_REQUEST], profile, options.debug, () => {
                console.log('Account linking created successfully.');
            });
        } else {
            collectAccountLinkingAnswers(accountLinking => {
                apiWrapper.callCreateAccountLinking(options.skillId, stage, accountLinking, profile, options.debug, () => {
                    console.log('Account linking created successfully.');
                });
            });
        }
    }
}

function buildGetAccountLinkingCommand(commander) {
    commander
        .command('get-account-linking')
        .usage('<-s|--skill-id <skill-id>> [-g|--stage <stage>] [-p|--profile <profile>] [--debug]')
        .description('get account linking configuration for a skill')
        .option('-s, --skill-id <skill-id>', 'skill-id for the skill')
        .option('-g, --stage <stage>', 'stage for the skill')
        .option('-p, --profile <profile>', 'ask cli profile')
        .option('--debug', 'ask cli debug mode')
        .action(handle);

    function handle(options) {
        if (!options.skillId) {
            console.error('Please input required parameter: skill-id.');
            process.exit(1);
        }
        let stage = options.stage || CONSTANTS.SKILL.STAGE.DEVELOPMENT;
        let profile = profileHelper.runtimeProfile(options.profile);

        apiWrapper.callGetAccountLinking(options.skillId, stage, profile, options.debug, (data) => {
            let response = tools.convertDataToJsonObject(data.body);
            if (response) {
                console.log(JSON.stringify(response, null, 2));
            }
        });
    }
}

function buildDeleteAccountLinkingCommand(commander) {
    commander
        .command('delete-account-linking')
        .usage('<-s|--skill-id <skill-id>> [-g|--stage <stage>] [-p|--profile <profile>] [--debug]')
        .description('delete account linking configuration for a skill')
        .option('-s, --skill-id <skill-id>', 'skill-id for the skill')
        .option('-g, --stage <stage>', 'stage for the skill')
        .option('-p, --profile <profile>', 'ask cli profile')
        .option('--debug', 'ask cli debug mode')
        .action(handle);

    function handle(options) {
        if (!options.skillId) {
            console.error('Please input required parameter: skill-id.');
            process.exit(1);
        }
        let stage = options.stage || CONSTANTS.SKILL.STAGE.DEVELOPMENT;
        let profile = profileHelper.runtimeProfile(options.profile);

        apiWrapper.callDeleteAccountLinking(options.skillId, stage, profile, options.debug, () => {
            console.log('Account linking removed successfully.');
        });
    }
}

function collectAccountLinkingAnswers(callback) {
    const accountLinking = {};
    const question1 = [
        {
            type: 'input',
            name: 'authorizationUrl',
            message: 'Authorization URL: '
        },
        {
            type: 'input',
            name: 'clientId',
            message: 'Client ID: '
        },
        {
            type: 'input',
            name: 'scopes',
            message: 'Scopes(separate by comma): '
        },
        {
            type: 'input',
            name: 'domains',
            message: 'Domains(separate by comma): '
        }
    ];
    inquirer.prompt(question1).then((answers) => {
        accountLinking.authorizationUrl = answers.authorizationUrl;
        accountLinking.clientId = answers.clientId;

        let tempScopes = answers.scopes.split(',')
            .map((scope) => {
                return scope.trim();
            })
            .filter((item) => {
                if (item.length > 0) {
                    return item;
                } else {
                    return null;
                }
            });
        accountLinking.scopes = tempScopes.length ? tempScopes : null;

        let tempDomains = answers.domains.split(',')
            .map((domain) => {
                return domain.trim();
            })
            .filter((item) => {
                if (item.length > 0) {
                    return item;
                } else {
                    return null;
                }
            });
        accountLinking.domains = tempDomains.length ? tempDomains : null;

        const question2 = {
            type: 'list',
            name: 'type',
            message: 'Authorization Grant Type: ',
            choices: [
                'AUTH_CODE',
                'IMPLICIT'
            ]
        };
        inquirer.prompt(question2).then((answers) => {
            accountLinking.type = answers.type;
            if (answers.type !== 'AUTH_CODE') {
                callback(accountLinking);
            } else {
                const question3 = [
                    {
                        type: 'input',
                        name: 'accessTokenUrl',
                        message: 'Access Token URI: '
                    },
                    {
                        type: 'password',
                        name: 'clientSecret',
                        message: 'Client Secret: ',
                        validate: function (input) {
                            if (!input.trim()) {
                                return "'Client Secret' cannot be empty.";
                            }
                            return true;
                        }
                    },
                    {
                        type: 'list',
                        name: 'accessTokenScheme',
                        message: 'Client Authentication Scheme: ',
                        choices: [
                            'HTTP_BASIC',
                            'REQUEST_BODY_CREDENTIALS'
                        ]
                    },
                    {
                        type: 'input',
                        name: 'defaultTokenExpirationInSeconds',
                        message: 'Optional* Default Access Token Expiration Time In Seconds: ',
                        validate: function (input) {
                            try {
                                // no input is ok
                                if (!input.trim()) {
                                    return true;
                                }

                                // test if input can be transformed into an integer
                                let result = parseInt(input);
                                if (isNaN(result)) {
                                    return "Token expiration time should be an integer.";
                                }

                                // the integer has to be greater than 0
                                if (result < 0) {
                                    return "Token expiration time cannot be set to a value less than 0.";
                                }
                                return true;
                            } catch (e) {
                                // in some cases, parseInt with string will throw error instead of NaN.
                                return "defaultTokenExpirationInSeconds can only be an integer.";
                            }
                        }
                    }
                ];
                inquirer.prompt(question3).then((answers) => {
                    accountLinking.accessTokenUrl = answers.accessTokenUrl;
                    accountLinking.clientSecret = answers.clientSecret;
                    accountLinking.accessTokenScheme = answers.accessTokenScheme;
                    if (answers.defaultTokenExpirationInSeconds) {
                        accountLinking.defaultTokenExpirationInSeconds = parseInt(answers.defaultTokenExpirationInSeconds);
                    }
                    callback(accountLinking);
                });
            }
        });
    });
}
