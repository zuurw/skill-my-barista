'use strict';
const parser = require('../skill-parser');
const fs = require('fs');
const path = require('path');
const CONSTANTS = require('../constants');

module.exports = {
    separateLambdaCreateUpdate: separateLambdaCreateUpdate,
    parseLambdaArn: parseLambdaArn,
    getLambdaFolderName: getLambdaFolderName,
    removeLATESTFromArn: removeLATESTFromArn,
    generateLambdaResourceList: generateLambdaResourceList
};

/**
 * separate Lambda by returning the createList and updateList in the callback
 *
 * Each list is consisted of metaData which contains following properties:
 * {uri, sourceDir, domain, region, customName, zipPath, arn}
 * 4 of them are guaranteed to exist: uri, sourceDir, domain, region
 *
 * For create deploy lambda, metaData has 4 at the beginning, and 2 extra after creation:
 * - customName: boolean, used to test if the createLambda's name is input by client
 *               or at 'ask new' stage (true)/ or just created on 'ask deploy'(false).
 * - arn: the actual lambda function arn from aws response.
 *
 * @param skillName
 * @param endpointsInfo
 * @param workspacePath
 * @param profile
 * @param callback
 */
function separateLambdaCreateUpdate(skillName, endpointsInfo, workspacePath, profile, callback) {
    let lambdaList = {
        createLambdaList: [],
        updateLambdaList: []
    };
    
    for (let domain of Object.keys(endpointsInfo)) {
        for (let region of Object.keys(endpointsInfo[domain])) {
            const uri = endpointsInfo[domain][region].uri;
            const sourceDir = endpointsInfo[domain][region].sourceDir;
            const workingPath = sourceDir ? path.join(workspacePath, sourceDir) : sourceDir;

            // sourceDir exists without uri -> create Lambda
            if (!uri) {
                if (!sourceDir) {
                    callback('Error parsing the skill with endpointInfo empty.', null);
                    return;
                } else if (!fs.existsSync(workingPath)) {
                    callback(`Source directory (${workingPath}) for the Lambda function not found.`, null);
                    return;
                } else {
                    lambdaList.createLambdaList.push({
                        arn: '',
                        functionName: `ask-${domain}-${skillName}-${profile}-${_getRandomInt(100000)}`,
                        awsRegion: CONSTANTS.REGION_MAPPING[region] || CONSTANTS.REGION_MAPPING.NA,
                        alexaUsage: [`${domain}/${region}`],
                        sourceDir: sourceDir,
                        customName: false
                    });
                }
            } else {
                if (parser.isHttpsUrl(uri)) { // Skip for Https uri
                    continue;
                } else if (parser.isLambdaArn(uri)) { // Lambda ARN exists
                    if (!sourceDir) {
                        continue;
                    } else if (!fs.existsSync(workingPath)) {
                        callback(`Source directory (${workingPath}) for the Lambda function not found.`, null);
                        return;
                    } else {
                        const lambdaParseInfo = parseLambdaArn(uri);
                        if (lambdaParseInfo && !_existedInTheList(lambdaParseInfo.arn, lambdaList.updateLambdaList)) {
                            lambdaList.updateLambdaList.push({
                                arn: lambdaParseInfo.arn,
                                sourceDir: sourceDir
                            });
                        }
                    }
                } else {
                    // skillSchema has been preprocessed by fn: generateSubmittingReadyManifest
                    // so that if there is uri (functionName), then the funcationName has not been found
                    // from the user's AWS, so that I can directly put into the createLambdaList group.
                    lambdaList.createLambdaList.push({
                        arn: '',
                        functionName: uri,
                        awsRegion: CONSTANTS.REGION_MAPPING[region] || CONSTANTS.REGION_MAPPING.NA,
                        alexaUsage: [`${domain}/${region}`],
                        sourceDir: sourceDir,
                        customName: true
                    });
                }
            }
        }
    }
    callback(null, lambdaList);
}

/**
 * create a random number
 *
 * @param max
 * @return {number}
 * @private
 */
function _getRandomInt(max) {
    return Math.floor(Math.random() * Math.floor(max));
}

/**
 * check whether a given ARN is existed in the lambda meta-data list
 *
 * @param arn
 * @param lambdaList
 * @return {boolean}
 * @private
 */
function _existedInTheList(arn, lambdaList) {
    for (let lambdaMetaData of lambdaList) {
        if (arn === lambdaMetaData.arn) {
            return true;
        }
    }
    return false;
}

/**
 * parse the given URI.
 *
 * if it's a vilad lambda ARN, it returns an object:
 * {
 *      'arn': uri without $LATEST if applicable,
 *      'awsRegion': aws region,
 *      'functionName': lambda function name,
 *      'version': the lambda version or 'null'
 * }
 * @param uri
 * @return {{arn: *, awsRegion: *, functionName: *, version: (*|null)}} | null
 */
function parseLambdaArn(uri) {
    // regex result should be:
    // [ arn, 'arn:aws:lambda:', region, 12Digits, functionName, ':version', version]
    let regexResult = CONSTANTS.REGEX.LAMBDA.exec(uri);
    if (!regexResult) { return; }

    // edge case. arn:$LATEST. remove the $LATEST
    if (regexResult[6] && regexResult[6] === '$LATEST') {
        uri = uri.slice(0, -8);
    }

    return {
        'arn': uri,
        'awsRegion': regexResult[2],
        'functionName': regexResult[4],
        'version': regexResult[6] || null
    };
}

function getLambdaFolderName(uri) {
    const parseResult = parseLambdaArn(uri);
    return `${parseResult.awsRegion}_${parseResult.functionName}`;
}

/**
 * remove '$LATEST' from lambda arn if applicable
 *
 * @param uri
 * @return {*}
 */
function removeLATESTFromArn(uri) {
    if (uri.slice(-8) === ':$LATEST') {
        return uri.slice(0, -8);
    }
    return uri;
}

/**
 * Generate lambda resources from endpoint
 * the format is:
 * {
 *  'arn': lambdaArn,
 *  'awsRegion': 'us-east-1',
 *  'functionName': functionName
 *  'alexaUsage': ["domain/region", "domain/region", ...],
 *  'revisionId': ""
 * }
 * @param endPointsInfo
 * @return {Array}
 * @private
 */
function generateLambdaResourceList(endPointsInfo) {
    const lambdaMap = {};
    for (let domain of Object.keys(endPointsInfo)) {
        for (let region of Object.keys(endPointsInfo[domain])) {
            const uri = endPointsInfo[domain][region].uri;
            const lambdaParseInfo = parseLambdaArn(uri);
            if (lambdaParseInfo && !lambdaMap[lambdaParseInfo.arn]) {
                lambdaMap[lambdaParseInfo.arn] = {
                    'arn': lambdaParseInfo.arn,
                    'awsRegion': lambdaParseInfo.awsRegion,
                    'functionName': lambdaParseInfo.functionName,
                    'alexaUsage': [],
                    'revisionId': ""
                };
            }
            lambdaMap[lambdaParseInfo.arn].alexaUsage.push(`${domain}/${region}`);
        }
    }

    // transform from map to list
    return Object.keys(lambdaMap).map(arn => lambdaMap[arn]);
}
