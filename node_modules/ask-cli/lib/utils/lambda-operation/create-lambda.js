'use strict';

const async = require('async');
const fs = require('fs');
const retry = require('retry');
const CONSTANTS = require('../constants');
const domainRegistry = require('../domain-registry');
const initAWS = require('../init-aws');
const upload = require('../../lambda/upload');
const displayUtil = require('../../utils/display-utility');
const lambdaUtils = require('../../resource/lambda-utils');

// Public
module.exports = {
    createLambda : (skillId, skillName, createLambdaList, awsProfile, callback) => {
        const roleName = 'ask-lambda-' + skillName.replace(/_/g, '-'); // IAM role doesn't allow underbar
        const createLambdaSpinner = new displayUtil.Spinner(' Creating lambda function...');
        if (createLambdaList.length === 0) {
            callback();
        } else {
            createLambdaSpinner.start();
            async.eachSeries(createLambdaList, (lambdaMetaData, asyncCallback) => {
                setTimeout(() => {
                    const aws = initAWS.initAWS(awsProfile);
                    if (!aws) {
                        asyncCallback('Cannot initialize aws');
                    }
                    // TODO can user give IAM role. if metaData.role... else...
                    createIAMRole(aws, roleName, lambdaMetaData.awsRegion, (err, arnData) => {
                        if (err) {
                            createLambdaSpinner.stop();
                            console.error('Create role error.\n' + err);
                            asyncCallback(err);
                        }
                        attachRolePolicy(aws, roleName, lambdaMetaData.awsRegion, (err) => {
                            if (err) {
                                createLambdaSpinner.stop();
                                console.error('Attach inline policy error.\n' + err);
                                asyncCallback(err);
                            }
                            createZip(lambdaMetaData, (err) => {
                                if (err) {
                                    createLambdaSpinner.stop();
                                    console.error('Read directory error.\n' + err);
                                    asyncCallback(err);
                                }
                                createLambdaFunction(aws, lambdaMetaData, arnData.Role.Arn, lambdaMetaData.awsRegion, (err, lambdaClient) => {
                                    if (err) {
                                        createLambdaSpinner.stop();
                                        console.error('Create Lambda error.\n' + err);
                                        asyncCallback(err);
                                    }
                                    addEventSource(skillId, lambdaClient, lambdaMetaData, (err) => {
                                        if (err) {
                                            createLambdaSpinner.stop();
                                            console.error('Add event source error.\n' + err);
                                            asyncCallback(err);
                                        }
                                        getLambdaFunctionRevisionId(lambdaClient, lambdaMetaData, (err) => {
                                            if (err) {
                                                createLambdaSpinner.stop();
                                                console.error('Get Lambda function error.\n' + err);
                                                asyncCallback(err);
                                            }
                                            asyncCallback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                }, CONSTANTS.CONFIGURATION.TIME_INTERVAL_FOR_ASYNC_REQUEST);
            }, (err) => {
                if (err) {
                    createLambdaSpinner.stop();
                    process.exit(1); // error message will show during creation
                }
                createLambdaSpinner.stop();
                callback(createLambdaList); // createLambdaList updates on the fly
            });
        }
    }
};

// Private
function createIAMRole(aws, roleName, awsRegion, callback) {
    const IAM = new aws.IAM({region: awsRegion});
    const params = {
        RoleName: roleName
    };
    IAM.getRole(params, (err, data) => {
        if (!err) {
            callback(null, data);
        } else {
            const policy = {
                Version: '2012-10-17',
                Statement: [
                    {
                        Effect: 'Allow',
                        Principal: {
                            Service: 'lambda.amazonaws.com'
                        },
                        Action: 'sts:AssumeRole'
                    }
                ]
            };
            params.AssumeRolePolicyDocument = JSON.stringify(policy);
            IAM.createRole(params, (err, data) => {
                callback(err, data);
            });
        }
    });
}

function attachRolePolicy(aws, roleName, awsRegion, callback) {
    const IAM = new aws.IAM({region: awsRegion});
    const params = {
        PolicyArn: "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole",
        RoleName: roleName
    };
    IAM.attachRolePolicy(params, (err, data) => {
        callback(err, data);
    });
}

function createZip(metaData, callback) {
    upload.createZip(metaData.sourceDir, (zipPath) => {
        metaData.zipPath = zipPath;
        callback();
    });
}

function createLambdaFunction(aws, metaData, roleArn, regionCode, callback) {
    const lambdaClient = new aws.Lambda({region: regionCode});
    const params = {
        Code: {
            ZipFile: fs.readFileSync(metaData.zipPath)
        },
        FunctionName: metaData.functionName,
        Handler: metaData.handler || 'index.handler',
        MemorySize: metaData.memorySize || 128,
        Role: metaData.role || roleArn,
        Runtime: metaData.runTime || 'nodejs6.10',
        Timeout: metaData.timeout || 8
    };
    const operation = retry.operation({
        retries: CONSTANTS.CONFIGURATION.RETRY.CREATE_LAMBDA.MAX_RETRY,
        minTimeout: CONSTANTS.CONFIGURATION.RETRY.CREATE_LAMBDA.MIN_TIME_OUT,
        factor: CONSTANTS.CONFIGURATION.RETRY.CREATE_LAMBDA.FACTOR
    });
    operation.attempt(() => {
        lambdaClient.createFunction(params, (err, functionData) => {
            if (operation.retry(err)) {
                return;
            }
            fs.unlinkSync(metaData.zipPath);
            if (err) {
                callback(err, null);
            } else {
                metaData.arn = functionData.FunctionArn;
                metaData.revisionId = functionData.RevisionId;
                callback(null, lambdaClient);
            }
        });
    });
}

function addEventSource(skillId, lambdaClient, metaData, callback) {
    const params = domainRegistry.getEventSourceParams(lambdaUtils.getDomainFromAlexaUsage(metaData), skillId);
    params.FunctionName = metaData.arn;
    params.RevisionId = metaData.revisionId;
    lambdaClient.addPermission(params, (err) => {
        if (err) {
            callback(err);
            return;
        }
        callback();
    });
}

function getLambdaFunctionRevisionId(lambdaClient, metaData, callback) {
    const params = {
        FunctionName: metaData.functionName
    };
    lambdaClient.getFunction(params, (err, functionData) => {
        if (err) {
            callback(err);
            return;
        }
        metaData.revisionId = functionData.Configuration.RevisionId;
        callback(null);
    });
}
