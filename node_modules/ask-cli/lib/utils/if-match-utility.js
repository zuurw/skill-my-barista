'use strict';

const path = require('path');
const jsonUtility = require('../utils/json-utility');
const configPath = path.join(process.cwd(), '.ask', 'config');
const CONSTANT = require('../utils/constants');
const lambdaEndpointUtility = require('../utils/lambda-operation/lambda-endpoint-utility');

module.exports = {
    recordModelEtag: recordModelEtag,
    recordSkillEtag: recordSkillEtag,
    recordLambdaRevisionId: recordLambdaRevisionId,
    getSkillETag: getSkillETag,
    getModelETag: getModelETag,
    getLambdaRevisionId: getLambdaRevisionId,
    getLambdaResourceList: getLambdaResourceList,
    removeModelEtag: removeModelETag,
    eraseSkillEtag: eraseSkillEtag
};

/**
 * Put models' eTags to skill package's config file.
 *
 * @param eTagList each item is an object with "locale" and "eTag" property.
 * @param profile
 * @param cloneConfigPath optional. if the param is omitted, CLI defaults to look for the config in the current workspace
 */
function recordModelEtag(eTagList, profile, cloneConfigPath) {
    if (!eTagList || eTagList.length === 0) {
        return; 
    }
    if (!cloneConfigPath) {
        cloneConfigPath = configPath;
    }
    let config = jsonUtility.read(cloneConfigPath);
    for (let eTagObject of eTagList) {
        let objectPath = ['deploy_settings', profile, 'resources', 'interactionModel', eTagObject.locale];
        let addingObject = {eTag: eTagObject.eTag};
        config = jsonUtility.insertObjectToObject(config, objectPath, addingObject);
    }
    jsonUtility.write(cloneConfigPath, config);
}

/**
 * Put skill's eTag to skill package's config file.
 *
 * @param eTag
 * @param profile
 * @param cloneConfigPath optional. if the param is omitted, CLI defaults to look for the config in the current workspace
 */
function recordSkillEtag(eTag, profile, cloneConfigPath) {
    if (!eTag) {
        return;
    }
    if (!cloneConfigPath) {
        cloneConfigPath = configPath;
    }
    let eTagObject = {eTag: eTag};
    jsonUtility.writeToProperty(cloneConfigPath,
        ['deploy_settings', profile, 'resources', 'manifest'],
        eTagObject);
}

/**
 * Delete the skill eTag from 'resources' in skill config file.
 * @param profile
 */
function eraseSkillEtag(profile) {
    let skillPath = ['deploy_settings', profile, 'resources', 'manifest'];
    let configObject = jsonUtility.read(configPath);
    let skillResource = jsonUtility.getPropertyValueFromObject(configObject, skillPath);
    if (skillResource) {
        delete skillResource.eTag;
        jsonUtility.addValueToProperty(configObject, skillPath, skillResource);
        jsonUtility.write(configPath, configObject);
    }
}

/**
 * Put Lambda functions' revision id to skill package's config file.
 *
 * @param refreshedLambdaList
 * listStructure:
   [{
        'arn': 'arn:...',
        'awsRegion': 'us-east-1',
        'functionName': 'ask-something',
        'alexaUsage': ['custom/default', 'smartHome/NA'],
        'revisionId': "sdlfkjlksdjf"
    },
    {
         ...
    }]
 * @param profile
 * @param cloneConfigPath optional. if the param is omitted, CLI defaults to look for the config in the current workspace
 */
function recordLambdaRevisionId(refreshedLambdaList, profile, cloneConfigPath) {
    if (!refreshedLambdaList || refreshedLambdaList.length === 0) { return; }
    _removeUnnecessaryProperties(refreshedLambdaList);
    if (!cloneConfigPath) {
        cloneConfigPath = configPath;
    }

    let config = jsonUtility.read(cloneConfigPath);
    let lambdaObjectPath = ['deploy_settings', profile, 'resources', 'lambda'];
    let localLambdaList = jsonUtility.getPropertyValueFromObject(config, lambdaObjectPath);

    // if the resources have lambda, override the existing properties' values and leave the rest as it is.
    // otherwise just put the refreshed lambda list in there
    let mergedLambdaList = localLambdaList ?
        _mergeRefreshedLambdaList(refreshedLambdaList, localLambdaList) : refreshedLambdaList;

    let insertPath = ['deploy_settings', profile, 'resources', 'lambda'];

    jsonUtility.addValueToProperty(config, insertPath, mergedLambdaList);
    jsonUtility.write(cloneConfigPath, config);
}

/**
 * Get skill's eTag for current skill package
 *
 * @param profile
 * @return {any} eTag string or undefined.
 */
function getSkillETag(profile) {
    const item = jsonUtility.getProperty(configPath, ['deploy_settings', profile, 'resources', 'manifest']);
    return item ? item.eTag : undefined;
}

/**
 * Get Models' eTags for current skill package.
 * @param profile
 * @return {any} object.locale.eTag = string or undefined.
 */
function getModelETag(profile) {
    const item = jsonUtility.getProperty(configPath, ['deploy_settings', profile, 'resources', 'interactionModel']);
    return item ? item : undefined;
}

function getLambdaRevisionId(profile) {
    const item = jsonUtility.getProperty(configPath, ['deploy_settings', profile, 'resources', 'lambda']);
    if (!item) {
        return undefined;
    }
    let lambdaRevisionIdMap = {};
    item.forEach((lambdaResource) => {
        lambdaRevisionIdMap[lambdaResource.arn] = lambdaResource.revisionId;
    });
    return lambdaRevisionIdMap;
}

function getLambdaResourceList(profile) {
    const item = jsonUtility.getProperty(configPath, ['deploy_settings', profile, 'resources', 'lambda']);
    return item ? item : undefined;
}

/**
 * Remove all the eTag info from interaction model inside 'resources' object.
 * @param profile
 */
function removeModelETag(profile) {
    let modelPath = ['deploy_settings', profile, 'resources', 'interactionModel'];
    let configObject = jsonUtility.read(configPath);
    let modelResource = jsonUtility.getPropertyValueFromObject(configObject, modelPath);
    if (modelResource) {
        delete modelResource.eTag;
        jsonUtility.addValueToProperty(configObject, modelPath, modelResource);
        jsonUtility.write(configPath, configObject);
    }
}

function _removeUnnecessaryProperties(list) {
    for (let item of list) {
        for (let excludedProperty of CONSTANT.IF_MATCH.LAMBDA_METADATA_EXCLUDE_PROPERTIES) {
            delete item[excludedProperty];
        }
    }
}

/**
 * merge refreshed lambda list with local lambda list.
 *
 * If find the uri match, override directly on the original lambdaMetaDataObject.
 * else pushes the new lambdaMetaDataObject to a temp list which will concat the local lambda list in the end.
 * in this way, the localLambdaList is fixed until the for loop is over,
 * also avoid additional comparision, which considering to add the new lambdaMetaDataObject after each inner loop.
 *
 * @param refreshedLambdaList
 * @param localLambdaList
 * @private
 */
function _mergeRefreshedLambdaList(refreshedLambdaList, localLambdaList) {
    let newList = [];
    let findMatch = false;
    for (let refreshedLambdaMetaData of refreshedLambdaList) {
        for (let originalLambdaMetaData of localLambdaList) {
            if (refreshedLambdaMetaData.arn === lambdaEndpointUtility.removeLATESTFromArn(originalLambdaMetaData.arn)) {
                findMatch = true;
                for (let key of Object.keys(refreshedLambdaMetaData)) {
                    originalLambdaMetaData[key] = refreshedLambdaMetaData[key];
                }
                break;
            }
        }
        if (findMatch) { findMatch = false; }
        else {
            newList.push(refreshedLambdaMetaData);
        }
    }
    return localLambdaList.concat(newList);
}
