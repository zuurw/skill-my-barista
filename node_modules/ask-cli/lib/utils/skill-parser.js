'use strict';

const path = require('path');
const { URL } = require('url');

const domainRegistry = require('./domain-registry');
const jsonUtility = require('./json-utility');
const lambdaEndpointUtility = require('../utils/lambda-operation/lambda-endpoint-utility');

/*
 * Get SkillInfo (Extract CLI relative info from manifest)
 *
 * @params manifest
 * @return skillInfo with following fields
 *       | skillName
 *       | endpointsInfo
 *       | publishLocaleList
 *       | domainList
 *       | hasLambdaFunction
 */
module.exports.extractSkillInfo = (manifest) => {
    let skillInfo = {
        'skillName': module.exports.parseSkillName(manifest),
        'endpointsInfo': module.exports.parseEndpointInfo(manifest),
        'publishLocaleList': module.exports.parsePublishingLocaleList(manifest),
        'domainList': module.exports.parseDomainList(manifest)
    };
    skillInfo.hasLambdaFunction = module.exports.hasLambdaFunction(skillInfo.endpointsInfo);
    if (!skillInfo.skillName || skillInfo.skillName.length === 0) {
        // delete domain check. the check will be done by backend
        return null;
    }
    return skillInfo;
};

/*
 * Get SkillName from manifest
 * Two notes on this function:
 * 1.The name in en-US is prioritized; if no en-US then use the first locale
 * 2.Filter the name by replacing all the invalid character to '-'
 *
 * @params manifest
 * @return skillName
 */
module.exports.parseSkillName = (manifest) => {
    let locales = jsonUtility.getPropertyValueFromObject(manifest,
        ['manifest', 'publishingInformation', 'locales']);
    if (!locales) {
        locales = jsonUtility.getPropertyValueFromObject(manifest,
            ['skillManifest', 'publishingInformation', 'locales']);
    }
    if (!locales) {
        return null;
    }
    let name;
    if (locales.hasOwnProperty('en-US')) {
        name = locales['en-US'].name;
    } else if (locales.hasOwnProperty('en-GB')){
        name = locales['en-GB'].name;
    } else {
        name = locales[Object.keys(locales)[0]].name;
    }
    let result = module.exports.filterSkillName(name);
    if (!result || result.length === 0) {
        console.error('Get skill name error. Skill name should not be empty.');
        return null;
    }
    return result;
};

/**
 * find the endpoint for lambda
 * @param manifest
 * @return {{}} return endpointsInfo
 *
 *{
 *    'domain': {
 *        'default': {
 *            'uri': 'something'
 *        },
 *        'NA': {
 *            'uri': 'something else'
 *        },
 *        'EU': {
 *            'uri': 'something else else..'
 *        }
 *    }
 *}
 */
module.exports.parseEndpointInfo = (manifest) => {
    let endpointsInfo = {};
    let domainList = module.exports.parseDomainList(manifest);
    if (!domainList || domainList.length === 0) {
        return endpointsInfo;
    }
    for (let domain of domainList) {
        let domainKey = domainRegistry.getSkillSchemaKey(domain);
        let domainInfo = jsonUtility.getPropertyValueFromObject(manifest, ['manifest', 'apis', domainKey]);
        if (!domainInfo) {
            domainInfo = jsonUtility.getPropertyValueFromObject(manifest, ['skillManifest', 'apis', domainKey]);
        }
        if (!domainInfo.hasOwnProperty('endpoint')) {
            continue;
        }

        if (!domainInfo.endpoint) {
            console.error(
                '[Error]: Invalid skill information. Please check skill.json against' +
                ' `.ask/config`. The "merge" object inside the config file will overwrite' +
                ' the existing field in skill.json at runtime.'
            );
            process.exit(1);
        }
        endpointsInfo[domain] = {};

        // Add default region to the list
        endpointsInfo[domain]['default'] = {};
        if (domainInfo.endpoint.hasOwnProperty('uri')) {
            endpointsInfo[domain]['default'].uri = domainInfo.endpoint.uri;
        }
        if (domainInfo.endpoint.hasOwnProperty('sourceDir')) {
            endpointsInfo[domain]['default'].sourceDir = domainInfo.endpoint.sourceDir;
        }
        if (Object.keys(endpointsInfo[domain]['default']).length === 0) {
            delete endpointsInfo[domain]['default'];
        }

        // Add endpoints in the 'regions' field. Only check 'regions' when default 'endpoint' exists
        if (domainInfo.hasOwnProperty('regions')) {
            let regionInfo = domainInfo.regions;
            for (let region of Object.getOwnPropertyNames(regionInfo)) {
                if (!regionInfo[region].hasOwnProperty('endpoint')) {
                    continue;
                }
                let endpointInfoForRegion = regionInfo[region].endpoint;
                endpointsInfo[domain][region] = {};
                if (endpointInfoForRegion.hasOwnProperty('uri')) {
                    endpointsInfo[domain][region].uri = endpointInfoForRegion.uri;
                }
                if (endpointInfoForRegion.hasOwnProperty('sourceDir')) {
                    endpointsInfo[domain][region].sourceDir = endpointInfoForRegion.sourceDir;
                }
                if (Object.keys(endpointsInfo[domain][region]).length === 0) {
                    delete endpointsInfo[domain][region];
                }
            }
        }


        // Delete the domain which doesn't have details in endpoint field
        if (Object.keys(endpointsInfo[domain]).length === 0) {
            delete endpointsInfo[domain];
        }
    }
    return endpointsInfo;
};

module.exports.parseDomainList = (manifest) => {
    let apis = jsonUtility.getPropertyValueFromObject(manifest, ['manifest', 'apis']);
    if (!apis) {
        apis = jsonUtility.getPropertyValueFromObject(manifest, ['skillManifest', 'apis']);
    }
    if (!apis) {
        return null;
    }
    if (Object.keys(apis).length < 1) {
        console.warn('Skill.json invalid. Skill domain not specified.');
        return null;
    }

    let domainList = [];
    for (let domain of domainRegistry.domainList()) {
        let domainKey = domainRegistry.getSkillSchemaKey(domain);
        if (apis.hasOwnProperty(domainKey)) {
            domainList.push(domain);
        }
    }
    return domainList;
};

module.exports.hasLambdaFunction = (endpointsInfo) => {
    if (!endpointsInfo || (endpointsInfo.constructor === Object && Object.keys(endpointsInfo).length === 0)) {
        return false;
    }
    for (let domain of Object.getOwnPropertyNames(endpointsInfo)) {
        for (let region of Object.getOwnPropertyNames(endpointsInfo[domain])) {
            if (endpointsInfo[domain][region].sourceDir && endpointsInfo[domain][region].sourceDir.length !== 0) {
                return true;
            }
            let uri = endpointsInfo[domain][region].uri;
            if (uri && uri.startsWith('arn:')) {
                return true;
            }
        }
    }
    return false;
};

module.exports.parsePublishingLocaleList = (manifest) => {
    let publishingLocalesInfo = jsonUtility.getPropertyValueFromObject(manifest,
        ['manifest', 'publishingInformation', 'locales']);
    if (!publishingLocalesInfo) {
        publishingLocalesInfo = jsonUtility.getPropertyValueFromObject(manifest,
            ['skillManifest', 'publishingInformation', 'locales']);
    }
    if (!publishingLocalesInfo) {
        return null;
    }
    return Object.keys(publishingLocalesInfo);
};

module.exports.getLambdaArnSetFromSkill = (manifest) => {
    const arnSet = new Set();
    const apiInfo = jsonUtility.getPropertyValueFromObject(manifest, ['manifest', 'apis']);
    if (!apiInfo) {
        return arnSet;
    }
    for (let domain of Object.keys(apiInfo)) {
        if (apiInfo[domain].hasOwnProperty('endpoint')) {
            const arn = apiInfo[domain].endpoint.uri;
            if (arn && module.exports.isLambdaArn(arn) && !arnSet.has(arn)) {
                arnSet.add(arn);
            }
        }
        if (apiInfo[domain].hasOwnProperty('regions')) {
            const regionInfo = apiInfo[domain].regions;
            for (let region of Object.keys(regionInfo)) {
                if (regionInfo[region].hasOwnProperty('endpoint')) {
                    const arn = regionInfo[region].endpoint.uri;
                    if (arn && module.exports.isLambdaArn(arn) && !arnSet.has(arn)) {
                        arnSet.add(arn);
                    }
                }
            }
        }
    }

    return arnSet;
};

/**
 * Retrieve the sourceDir value from lambdaArn. 
 * This function will first check the "merge" field in config file for alexa's usage (domain + region), and then 
 * get the relative path from the manifest.
 * @param {object} manifest 
 * @param {object} configContent 
 * @param {string} lambdaArn 
 * @param {string} profile 
 */
module.exports.getSourceDirByLambdaArn = (manifest, configContent, lambdaArn, profile) => {
    const lambdaArnParseResult = lambdaEndpointUtility.parseLambdaArn(lambdaArn);
    if (!lambdaArnParseResult) {
        return null;
    }
    const lambdaName = lambdaArnParseResult.functionName;
    const apisInfo = jsonUtility.getPropertyValueFromObject(configContent, ['deploy_settings', profile, 'merge', 'manifest', 'apis']);
    if (!apisInfo) {
        return null;
    }

    for (let domain of Object.keys(apisInfo)) {
        const domainInfo = apisInfo[domain];
        if (!domainInfo || Object.keys(domainInfo).length === 0) {
            continue;
        }
        
        if (domainInfo.hasOwnProperty('endpoint') && domainInfo.endpoint.hasOwnProperty('uri')) {
            if (lambdaArn === domainInfo.endpoint.uri || lambdaName === domainInfo.endpoint.uri) {
                return jsonUtility.getPropertyValueFromObject(manifest, ['manifest', 'apis', domain, 'endpoint', 'sourceDir']);
            }
        }

        if (domainInfo.hasOwnProperty('regions') && Object.keys(domainInfo.regions).length !== 0) {
            for (let region of Object.keys(domainInfo.regions)) {
                const regionUri = jsonUtility.getPropertyValueFromObject(domainInfo, ['regions', region, 'endpoint', 'uri']);
                if (!regionUri) {
                    continue;
                }
                if (lambdaArn === regionUri || lambdaName === regionUri) {
                    return jsonUtility.getPropertyValueFromObject(manifest, ['manifest', 'apis', domain, 'regions', region, 'endpoint', 'sourceDir']);
                }
            }
        }
    }

    return null;
};

module.exports.isSkillNameValid = (name) => {
    let filteredName = name.match(/([a-zA-Z0-9-_]+)/g);
    if (filteredName && filteredName[0] === name) {
        return true;
    } else {
        return false;
    }
};

module.exports.isValidLambdaFunctionName = (functionName) => {
    if (functionName.length === 0) {
        return false;
    }
    let re = /[a-zA-Z0-9-_]+/;
    let capturedStringArray = functionName.match(re);
    return functionName.length === capturedStringArray[0].length ? true : false;
};

module.exports.isAbsoluteURL = (url) => {
    return module.exports.isLambdaArn(url) || module.exports.isHttpsUrl(url) ? true : false;
};

module.exports.isLambdaArn = (url) => {
    const lambdaRegex = /arn:aws:lambda:[a-z]+-[a-z]+-[0-9]:[0-9]{12}:function:[a-zA-Z0-9-_]+(\/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})?(:[a-zA-Z0-9-_]+)?/;
    return url && lambdaRegex.test(url) ? true : false;
};

module.exports.isHttpsUrl = (url) => {
    try {
        const urlToValdate = new URL(url);
        return urlToValdate.protocol === 'https:' ? true : false;
    } catch (error) {
        return false;
    }
};

/*
 * Filter the name by replacing all the invalid character to '_'
 *
 * @params skillName
 * @return filteredName
 */
module.exports.filterSkillName = (name) => {
    return name.replace(/[^a-zA-Z0-9-_]+/g, '_');
};

module.exports.reorganizeToObjectList = (endpointsInfo) => {
    let listOfLambdaMetaDataObject = [];
    for (let domain of Object.keys(endpointsInfo)) {
        let reversedMap = reverseKeyValue(endpointsInfo[domain]);
        if (Object.keys(reversedMap).length === 0) {
            continue;
        } else if (Object.keys(reversedMap).length === 1) {
            let addingObject = {};
            addingObject.sourceDirFromDomainLevel = domain;
            addingObject.domain = domain;
            addingObject.regions = reversedMap[Object.keys(reversedMap)[0]];
            addingObject.uri = Object.keys(reversedMap)[0];
            addingObject.directoryName = 'default';
            listOfLambdaMetaDataObject.push(addingObject);
        } else {
            for (let arn of Object.keys(reversedMap)) {
                let addingObject = {};
                let regionList = reversedMap[arn];
                let directoryName = regionList.join('-');
                let sourceDir = path.join(domain, directoryName);
                addingObject.sourceDirFromDomainLevel = sourceDir;
                addingObject.domain = domain;
                addingObject.regions = regionList;
                addingObject.uri = arn;
                addingObject.directoryName = directoryName;
                listOfLambdaMetaDataObject.push(addingObject);
            }
        }
    }
    return listOfLambdaMetaDataObject;
};

function reverseKeyValue(domainObject) {
    let reversedObject = {};
    for (let region of Object.keys(domainObject)) {
        if (domainObject[region].uri.startsWith('https://')) {
            continue;
        }
        if (!reversedObject.hasOwnProperty(domainObject[region].uri)) {
            reversedObject[domainObject[region].uri] = [];
        }
        reversedObject[domainObject[region].uri].push(region);
    }
    return reversedObject;
}
