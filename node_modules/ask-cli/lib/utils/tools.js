'use strict';

const crypto = require('crypto');
const path = require('path');
const fs = require('fs');
const jsonUtility = require('./json-utility');

// Public
module.exports = {
    convertDataToJsonObject: convertDataToJsonObject,
    removeDirectory: removeDirectory,
    generateSID: generateSID,
    v1ManifestTransformer: v1ManifestTransformer,
    collate: collate
};

function convertDataToJsonObject(data) {
    let response = data;
    try {
        if (typeof(data) === 'string') {
            response = JSON.parse(data);
        }
    } catch (e) {
        console.error('Failed to parse the response from Alexa Skill Management API Service.');
        return null;
    }
    return response;
}

function removeDirectory(dir) {
    if (fs.existsSync(dir)) {
        fs.readdirSync(dir).forEach((file) => {
            let curPath = path.join(dir, file);
            if (fs.lstatSync(curPath).isDirectory()) {
                removeDirectory(curPath);
            } else {
                fs.unlinkSync(curPath);
            }
        });
        fs.rmdirSync(dir);
    }
}

function generateSID() {
    let part0 = 'lc-';
    let part1 = randString(8) + '-';
    let part2 = randString(4) + '-';
    let part3 = randString(4) + '-';
    let part4 = randString(4) + '-';
    let part5 = randString(12);
    return part0 + part1 + part2 + part3 + part4 + part5;
}

/**
 * @param skillJSONFilePath
 *
 * transform skill.json from v0 version to v1 version
 * change "skillManifest" to "manifest"
 */
function v1ManifestTransformer(skillJSONPath, isLowLevelCommand, profile) {
    let skillJSONContent = jsonUtility.read(skillJSONPath);
    if (skillJSONContent.hasOwnProperty('skillManifest')) {
        skillJSONContent.manifest = skillJSONContent.skillManifest;
        delete skillJSONContent.skillManifest;
        console.warn("[Warn]: Changed the property name from 'skillManifest' to 'manifest' in skill.json " +
            "in order to fit the v1 Alexa Skill Management APIs accepted format.");
        jsonUtility.write(skillJSONPath, skillJSONContent);
    }

    if (isLowLevelCommand) return;
    let cwd = process.cwd();
    if (fs.existsSync(path.join(cwd, '.ask')) &&
        fs.existsSync(path.join(cwd, '.ask', 'config'))) {
        let propertyPath = ['deploy_settings', profile, 'merge', 'skillManifest'];
        let configContent = jsonUtility.read(path.join(cwd, '.ask', 'config'));
        let skillManifest = jsonUtility.getPropertyValueFromObject(configContent, propertyPath);
        if (skillManifest) {
            jsonUtility.insertObjectToObject(
                configContent,
                ['deploy_settings', profile, 'merge', 'manifest'],
                skillManifest);
            jsonUtility.deletePropertyFromJsonObject(configContent, propertyPath);
            jsonUtility.write(path.join(cwd, '.ask', 'config'), configContent);
            console.warn("[Warn]: Changed the property name from 'skillManifest' to 'manifest' in .ask/config " +
                "in order to fit the v1 Alexa Skill Management APIs accepted format.");
        }
    }
}

function randString(n) {
    if (n<0) {
        return '';
    }
    return crypto.randomBytes(Math.ceil(n/2)).toString('hex').slice(0,n);
}

function collate(baseLayer, overrideLayer) {
    function collateHelper(base, top) {
        for (let p of Object.getOwnPropertyNames(top)) {
            if (base[p] && base[p].constructor === Array) {
                if (top[p].constructor === Array) {
                    base[p] = top[p];
                    continue;
                }
                console.error(`[Error]: Merge failed. Two merging objects' have same property name, "${base[p]}", but different value type.`);
                process.exit(1);
            }
            if (top[p].constructor === Object && base.hasOwnProperty(p)) {
                collateHelper(base[p], top[p]);
                continue;
            }
            base[p] = top[p];
        }
    }
    if (!overrideLayer) {
        return JSON.parse(JSON.stringify(baseLayer));
    }
    let deepCopyFirstLayer = JSON.parse(JSON.stringify(baseLayer));
    let deepCopyOverrideLayer = JSON.parse(JSON.stringify(overrideLayer));
    collateHelper(deepCopyFirstLayer, deepCopyOverrideLayer);
    return deepCopyFirstLayer;
}