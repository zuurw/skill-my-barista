'use strict';

const jsonRead = require('../utils/json-read');
const oauth2 = require('simple-oauth2');
const jsonfile = require('jsonfile');
const path = require('path');
const fs = require('fs');
const os = require('os');
const CONSTANTS = require('../utils/constants');

module.exports = {
    createOAuth: createOAuth,
    tokenRefreshAndRead: tokenRefreshAndRead,
    writeToken: writeToken
};

/* If you want to create tools to call SMAPI(Skill Management API),
 * please create your own clientId and clientSecret through LWA (login with Amazon).
 * https://login.amazon.com/website.
 *
 * You can find necessary scopes for LWA to call SMAPI here:
 * https://developer.amazon.com/docs/smapi/ask-cli-intro.html#smapi-intro
 */

function createOAuth(clientId, clientSecret) {
    // if no inputs, it default back to CLI credentials.
    if (!clientId && !clientSecret) {
        clientSecret = CONSTANTS.LWA.CLI_DEFAULT_CREDENTIALS.clientSecret;
        clientId = CONSTANTS.LWA.CLI_DEFAULT_CREDENTIALS.clientId;
    }
    const AUTH_URL = {
        host: 'https://www.amazon.com',
        path: '/ap/oa'
    };
    const TOKEN_URL = {
        host: 'https://api.amazon.com',
        path: '/auth/o2/token'
    };
    return oauth2.create({
        client: {
            id: clientId,
            secret: clientSecret
        },
        auth: {
            authorizeHost: AUTH_URL.host,
            authorizePath: AUTH_URL.path,
            tokenHost: TOKEN_URL.host,
            tokenPath: TOKEN_URL.path
        }
    });
}

function tokenRefreshAndRead(params, profile, callback) {
    if (profile === CONSTANTS.PLACEHOLDER.ENVIRONMENT_VAR.PROFILE_NAME) {
        // if there's refreshToken, use that first since this profile is using env var,
        // cannot find whether accessToken expired or not.
        let askRefreshToken = process.env.ASK_REFRESH_TOKEN;
        if (askRefreshToken && askRefreshToken.length > 0) {
            refreshToken(profile, (refreshedAccessToken) => {
                params.headers.Authorization = refreshedAccessToken;
                callback(params);
            });
            return;
        }

        // if no refreshToken, fallback to accessToken
        let askAccessToken = process.env.ASK_ACCESS_TOKEN;
        if (askAccessToken && askAccessToken.length > 0) {
            params.headers.Authorization = askAccessToken;
            callback(params);
        }
        return;
    }
    if (!fs.existsSync(path.join(os.homedir(), '.ask'))) {
        console.warn('Failed to get authorization information.\n' +
            'Please run "ask init" to initialize ASK cli.');
        return;
    }
    if (!fs.existsSync(path.join(os.homedir(), '.ask', 'cli_config'))) {
        console.warn('Failed to get CLI config.\n' +
            'Please run "ask init" to initialize ASK cli.');
        return;
    }
    if (!isTokenExpired(profile)) {
        params.headers.Authorization = readAccessToken(profile);
        callback(params);
    } else {
        refreshToken(profile, (refreshedAccessToken) => {
            params.headers.Authorization = refreshedAccessToken;
            callback(params);
        });
    }
}

function isTokenExpired(profile) {
    let OAuth = module.exports.createOAuth();
    let token = OAuth.accessToken.create(readToken(profile));
    return token.expired();
}

function readAccessToken(profile) {
    let cliConfig = jsonRead.readFile(path.join(os.homedir(), '.ask', 'cli_config'));
    if (!cliConfig) {
        return;
    }
    return jsonRead.getProperty(cliConfig, '.profiles.' + profile + '.token.access_token');
}

function refreshToken(profile, callback) {
    let OAuth = module.exports.createOAuth();
    let oldToken = readToken(profile);
    if (!oldToken) {
        return;
    }
    let token = OAuth.accessToken.create(oldToken);
    token.refresh((err, result) => {
        if (err) {
            console.error(err + '\nFailed to refresh access token.');
            return;
        } else {
            if (profile === CONSTANTS.PLACEHOLDER.ENVIRONMENT_VAR.PROFILE_NAME) {
                callback(result.token.access_token);
            } else {
                writeToken(result.token, profile);
                callback(jsonRead.getProperty(result, '.token.access_token'));
            }
        }
    });
}

function readToken(profile) {
    if (profile === CONSTANTS.PLACEHOLDER.ENVIRONMENT_VAR.PROFILE_NAME) {
        return {
            'access_token': "ACCESS_TOKEN_PLACE_HOLDER",
            'refresh_token': process.env.ASK_REFRESH_TOKEN,
            'token_type': 'bearer',
            'expires_in': 0,
            'expires_at': 0
        }
    }
    let cliConfig = jsonRead.readFile(path.join(os.homedir(), '.ask', 'cli_config'));
    if (!cliConfig) {
        return;
    }
    let token = jsonRead.getProperty(cliConfig, '.profiles.' + profile + '.token');
    if (!token) {
        return;
    }
    return {
        'access_token': token.access_token,
        'refresh_token': token.refresh_token,
        'token_type': token.token_type,
        'expires_in': token.expires_in,
        'expires_at': token.expires_at
    };
}

function writeToken(token, profile) {
    let configPath = path.join(os.homedir(), '.ask', 'cli_config');
    let config = jsonRead.readFile(configPath);
    if (!config) {
        return;
    }
    let configToken = {
        'access_token': token.access_token,
        'refresh_token': token.refresh_token,
        'token_type': token.token_type,
        'expires_in': token.expires_in,
        'expires_at': token.expires_at
    };
    config.profiles[profile].token = configToken;
    jsonfile.writeFileSync(configPath, config, {spaces: 2});
}
