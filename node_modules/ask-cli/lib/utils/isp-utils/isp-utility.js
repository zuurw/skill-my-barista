'use strict';

const fs = require('fs');
const os = require('os');
const path = require('path');

const jsonUtility = require('../../utils/json-utility');
const tools = require('../../utils/tools');
const ispConstants = require('../../utils/isp-utils/isp-constants');

const ISP_PRODUCT_TYPE_LIST = Object.freeze(Object.keys(ispConstants.ISP_PRODUCT_TYPE).map(function (productType) {
    return ispConstants.ISP_PRODUCT_TYPE[productType];
}));
const ISP_API_LIST = Object.freeze(Object.keys(ispConstants.API).map(function (api) {
    return ispConstants.API[api];
}));

const ISP_DEPLOY_STATUS_LIST = Object.freeze(Object.keys(ispConstants.DEPLOY_STATUS).map(function (deployStatus) {
    return ispConstants.DEPLOY_STATUS[deployStatus];
}));

const ISP_PURCHASABLE_STATE_LIST = Object.freeze(Object.keys(ispConstants.ISP_PURCHASABLE_STATE).map(function (purchasableState) {
    return ispConstants.ISP_PURCHASABLE_STATE[purchasableState];
}));

module.exports = {
    isISPFileValid: isISPFileValid,
    isISPTypeValid: isISPTypeValid,
    isISPConfigValid: isISPConfigValid,
    isISPNameValid: isISPNameValid,
    isISPApi: isISPApi,
    isISPConfigDeployStatusValid: isISPConfigDeployStatusValid,
    isISPPurchasableStateValid: isISPPurchasableStateValid,
    getVendorIDFromProfile: getVendorIDFromProfile,
    isAtSkillRoot: isAtSkillRoot,
    getISPFileName: getISPFileName,
    handleAPIResponse: handleAPIResponse,
    getISPRootPath: getISPRootPath,
    getConfigPath: getConfigPath,
    getISPConfigs: getISPConfigs,
    replaceISPConfigs: replaceISPConfigs,
    getFormattedErrorString: getFormattedErrorString,
    getISPFiles: getISPFiles
};

/**
 * Validate in-skill product file path
 * @param filePath in-skill product file path
 * @param callback callback to handle response
 */
function isISPFileValid(filePath, callback) {
    if (!filePath || !fs.existsSync(filePath)) {
        callback(ispConstants.ERROR.MISSING_ISP_FILE);
        return;
    }
    if (!fs.lstatSync(filePath).isFile() || path.extname(filePath) !== '.json') {
        callback(ispConstants.ERROR.INVALID_ISP_FILE + ": " + filePath);
        return;
    }
    callback();
}

/**
 * Validate in-skill product type
 * @param type in-skill product type
 * @param isOptional whether the type is optional
 * @param callback callback to handle the response
 */
function isISPTypeValid(type, isOptional, callback) {
    if (!type) {
        if (!isOptional) {
            callback(ispConstants.ERROR.MISSING_ISP_TYPE);
            return;
        }
    } else {
        if (ISP_PRODUCT_TYPE_LIST.indexOf(type.toUpperCase()) === -1) {
            callback(ispConstants.ERROR.INVALID_ISP_TYPE);
            return;
        }
    }
    callback();
}

/**
 * Validate in-skill product name
 * @param ispName the name of the in-skill product
 * @returns {boolean} true if the name is valid, false otherwise
 */
function isISPNameValid(ispName) {
    if (!ispName || ispName.length < ispConstants.NUMBERS.MIN_ISP_NAME_LENGTH || ispName.length > ispConstants.NUMBERS.MAX_ISP_NAME_LENGTH) {
        return false;
    }
    const filteredName = ispName.match(/([a-zA-Z0-9-_]+)/g);
    if (filteredName && filteredName[0] === ispName) {
        return true;
    } else {
        return false;
    }
}

/**
 * Validate the in-skill product configuration object
 * @param ispConfig the in-skill product configuration object
 * @returns {boolean} true if the in-skill product configuration is valid, false otherwise
 */
function isISPConfigValid(ispConfig) {
    if (!ispConfig || !ispConfig.productId || !ispConfig.filePath) {
        console.error(ispConstants.ERROR.INVALID_ISP_CONFIG);
        return false;
    }
    return true;
}

/**
 * Validate the in-skill product deploy status in the configuration
 * @param deployStatus the status of the ISP deployment
 * @returns {boolean} true if the deploy status is valid
 */
function isISPConfigDeployStatusValid(deployStatus) {
    return deployStatus && (ISP_DEPLOY_STATUS_LIST.indexOf(deployStatus) > -1);
}

/**
 * Validate the in-skill product purchasable state
 * @param purchasableState the purchasableState of ISP
 * @returns {*|boolean} true if the purchasableState is valid
 */
function isISPPurchasableStateValid(purchasableState) {
    return purchasableState && (ISP_PURCHASABLE_STATE_LIST.indexOf(purchasableState) > -1);
}

/**
 * Get vendor ID from given user profile
 * @param profile user profile name
 * @returns {String} vendor ID
 */
function getVendorIDFromProfile(profile) {
    const configFile = path.join(os.homedir(), '.ask', 'cli_config');

    if (!fs.existsSync(configFile)) {
        return null;
    }

    return jsonUtility.getProperty(configFile, ['profiles', profile, 'vendor_id']);
}

/**
 * Verify if it's at the skill project root directory
 * @returns {boolean} true if it's at skill project root directory
 */
function isAtSkillRoot() {
    const currentDirectory = process.cwd();
    const skillFilePath = path.join(currentDirectory, 'skill.json');
    const configFilePath = path.join(currentDirectory, '.ask', 'config');

    if (fs.existsSync(skillFilePath) && fs.existsSync(configFilePath)) {
        return true;
    }
    return false;
}

/**
 * Get file name for in-skill product JSON
 * @param title title of ISP
 * @param subfixNum sufix number if there're duplicates
 * @returns {string} file name of ISP JSON
 */
function getISPFileName(title, subfixNum) {
    return (title + (subfixNum ? ('_' + subfixNum) : '') + '.json');
}

/**
 * Check if the api name is one of the in-skill product APIs
 * @param apiName
 * @returns {boolean}
 */
function isISPApi(apiName) {
    if (!apiName) {
        return false;
    }
    return ISP_API_LIST.indexOf(apiName.toLowerCase()) > -1;
}

/**
 * Handle the response from in-skill product APIs
 * @param apiName in-skill product api name
 * @param response response received from API
 * @param callback the callback function to handle the response
 */
function handleAPIResponse(apiName, response, callback) {
    /**
     * return the error message when the eTag doesn't match
     */
    const statusCode = response.statusCode;
    const responseBody = response.body ? tools.convertDataToJsonObject(response.body) : null;
    const eTag = response.headers.etag;

    if (statusCode === 412) {
        callback(ispConstants.ERROR.MISMATCH_ETAG);
        return;
    }
    if (statusCode >= 400) {
        callback(responseBody);
        return;
    }
    callback(null, responseBody, eTag);
}

/**
 * Get the in-skill product root path based on given skill project path
 * @param skillProjectPath the path of the skill project
 * @returns {*|string} path the in-skill products are saved to
 */
function getISPRootPath(skillProjectPath) {
    return path.join(skillProjectPath, ispConstants.DIRECTORY.ISP_ROOT);
}

/**
 * Get the path of configuration file based on given skill project path
 * @param skillProjectPath the path of the skill project
 * @returns {*|string} path the configuration file is saved to
 */
function getConfigPath(skillProjectPath) {
    return path.join(skillProjectPath, '.ask', 'config');
}

/**
 * Get the in-skill product configuration from the skill project configuration file
 * @param skillProjectPath the path of the skill project
 * @param profile the ASK CLI user profile
 * @returns {*}
 */
function getISPConfigs(skillProjectPath, profile) {
    const projectConfigFile = getConfigPath(skillProjectPath);

    if (!fs.existsSync(projectConfigFile) || !profile) {
        console.error('Cannot get in-skill product configurations from skill project config file');
        return;
    }

    const propertyPathArray = ['deploy_settings', profile, 'in_skill_products'];
    const ispConfigs = jsonUtility.getProperty(projectConfigFile, propertyPathArray);
    return ispConfigs ? ispConfigs : [];
}

/**
 * Replace the in-skill product configurations with the latest information
 * @param skillProjectPath the path of the skill project
 * @param profile the ASK CLi user profile
 * @param ispConfigs list of in-skill product configuration objects
 */
function replaceISPConfigs(skillProjectPath, profile, ispConfigs) {
    const projectConfigFile = getConfigPath(skillProjectPath);

    if (!fs.existsSync(projectConfigFile) || !profile) {
        console.error('Cannot get in-skill product configurations from skill project config file');
        return;
    }

    const propertyPathArray = ['deploy_settings', profile, 'in_skill_products'];
    jsonUtility.writeToProperty(projectConfigFile, propertyPathArray, ispConfigs);
}

/**
 * Get the formatted error string from the error object
 * @param error error object
 * @returns {string} string that contains the error information
 */
function getFormattedErrorString(error) {
    if (error) {
        return '[Error]: ' + (typeof error === 'object' ? JSON.stringify(error, null, 2) : error);
    }
    return '';
}

/**
 * Get all the in-skill product files from skillProjectPath/isp recursively
 * @param skillProjectPath the root path of the skill project
 * @param curDir the current directory
 * @param fileSet set of ISP files
 * @param depth current depth of discovery, the base is 0 and the maximum depth we allow is 1
 * @returns {*|Array} array of in-skill product files
 */
function getISPFiles(skillProjectPath, curDir, fileSet, depth) {
    fileSet = fileSet || new Set();
    depth = depth || 0;
    if (!fs.existsSync(curDir) || depth > 1) {
        return fileSet;
    }
    depth++;
    const dirList = fs.readdirSync(curDir);

    dirList.forEach(dir => {
        const dirPath = path.join(curDir, dir);
        const dirStat = fs.lstatSync(dirPath);
        if (dirStat.isDirectory()) {
            getISPFiles(skillProjectPath, dirPath, fileSet, depth);
        } else if (dirStat.isFile() && path.extname(dir) === '.json') {
            fileSet.add(path.relative(skillProjectPath, dirPath));
        }
    });

    return fileSet;
}
